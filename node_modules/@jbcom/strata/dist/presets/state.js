/**
 * State Presets
 *
 * Pre-configured state templates for common game types.
 */
export const DEFAULT_RPG_STATE = {
    player: {
        level: 1,
        experience: 0,
        health: 100,
        maxHealth: 100,
        mana: 50,
        maxMana: 50,
        strength: 10,
        dexterity: 10,
        intelligence: 10,
        wisdom: 10,
        constitution: 10,
        charisma: 10,
    },
    inventory: [],
    gold: 0,
    quests: [],
    currentLocation: 'starting_village',
    visitedLocations: ['starting_village'],
    gameFlags: {},
    playTime: 0,
};
export const DEFAULT_PUZZLE_STATE = {
    currentLevel: 1,
    totalLevels: 50,
    score: 0,
    moves: 0,
    movesLimit: undefined,
    timeElapsed: 0,
    timeLimit: undefined,
    stars: 0,
    hints: 3,
    isPaused: false,
    levelData: undefined,
    unlockedLevels: [1],
    achievements: [],
};
export const DEFAULT_PLATFORMER_STATE = {
    lives: 3,
    maxLives: 5,
    coins: 0,
    score: 0,
    highScore: 0,
    currentWorld: 1,
    currentLevel: 1,
    checkpointX: 0,
    checkpointY: 0,
    powerUps: [],
    keys: 0,
    unlockedWorlds: [1],
    collectibles: [],
    timeAttackBest: undefined,
};
export const DEFAULT_SANDBOX_STATE = {
    worldName: 'New World',
    worldSeed: 0, // Will be set dynamically in createSandboxState
    blocks: [],
    entities: [],
    playerPosition: { x: 0, y: 64, z: 0 },
    playerRotation: { x: 0, y: 0, z: 0 },
    playerInventory: [],
    timeOfDay: 0,
    weather: 'clear',
    gameMode: 'survival',
    difficulty: 'normal',
    modifiedChunks: [],
};
export const DEFAULT_COUNTER_STATE = {
    count: 0,
    lastUpdated: Date.now(),
};
export const RPG_STATE_PRESET = {
    name: 'rpg',
    description: 'Role-playing game state with player stats, inventory, quests, and game flags',
    initialState: DEFAULT_RPG_STATE,
    autoSaveConfig: {
        enabled: true,
        intervalMs: 120000,
        maxSlots: 3,
        saveOnChange: false,
        debounceMs: 5000,
        storageKey: 'rpg_autosave',
    },
    maxUndoSize: 100,
};
export const PUZZLE_STATE_PRESET = {
    name: 'puzzle',
    description: 'Puzzle game state with levels, score, moves, and achievements',
    initialState: DEFAULT_PUZZLE_STATE,
    autoSaveConfig: {
        enabled: true,
        intervalMs: 60000,
        maxSlots: 1,
        saveOnChange: true,
        debounceMs: 2000,
        storageKey: 'puzzle_autosave',
    },
    maxUndoSize: 200,
};
export const PLATFORMER_STATE_PRESET = {
    name: 'platformer',
    description: 'Platformer game state with lives, coins, levels, and power-ups',
    initialState: DEFAULT_PLATFORMER_STATE,
    autoSaveConfig: {
        enabled: true,
        intervalMs: 30000,
        maxSlots: 3,
        saveOnChange: false,
        debounceMs: 3000,
        storageKey: 'platformer_autosave',
    },
    maxUndoSize: 50,
};
export const SANDBOX_STATE_PRESET = {
    name: 'sandbox',
    description: 'Sandbox/voxel game state with world blocks, entities, and player data',
    initialState: DEFAULT_SANDBOX_STATE,
    autoSaveConfig: {
        enabled: true,
        intervalMs: 300000,
        maxSlots: 5,
        saveOnChange: false,
        debounceMs: 10000,
        storageKey: 'sandbox_autosave',
    },
    maxUndoSize: 30,
};
export const COUNTER_STATE_PRESET = {
    name: 'counter',
    description: 'Simple counter state for demos and testing',
    initialState: DEFAULT_COUNTER_STATE,
    autoSaveConfig: {
        enabled: true,
        intervalMs: 10000,
        maxSlots: 1,
        saveOnChange: true,
        debounceMs: 1000,
        storageKey: 'counter_autosave',
    },
    maxUndoSize: 100,
};
export const ALL_STATE_PRESETS = [
    RPG_STATE_PRESET,
    PUZZLE_STATE_PRESET,
    PLATFORMER_STATE_PRESET,
    SANDBOX_STATE_PRESET,
    COUNTER_STATE_PRESET,
];
export function getStatePreset(name) {
    return ALL_STATE_PRESETS.find((preset) => preset.name === name);
}
export const AUTOSAVE_CONFIG_FREQUENT = {
    enabled: true,
    intervalMs: 30000,
    maxSlots: 3,
    saveOnChange: true,
    debounceMs: 1000,
};
export const AUTOSAVE_CONFIG_MODERATE = {
    enabled: true,
    intervalMs: 120000,
    maxSlots: 3,
    saveOnChange: false,
    debounceMs: 5000,
};
export const AUTOSAVE_CONFIG_INFREQUENT = {
    enabled: true,
    intervalMs: 300000,
    maxSlots: 5,
    saveOnChange: false,
    debounceMs: 10000,
};
export const AUTOSAVE_CONFIG_DISABLED = {
    enabled: false,
    intervalMs: 0,
    maxSlots: 0,
    saveOnChange: false,
    debounceMs: 0,
};
export function createRPGState(overrides) {
    return { ...DEFAULT_RPG_STATE, ...overrides };
}
export function createPuzzleState(overrides) {
    return { ...DEFAULT_PUZZLE_STATE, ...overrides };
}
export function createPlatformerState(overrides) {
    return { ...DEFAULT_PLATFORMER_STATE, ...overrides };
}
export function createSandboxState(overrides) {
    // Generate fresh seed if not provided in overrides
    const worldSeed = overrides?.worldSeed ?? Date.now();
    return { ...DEFAULT_SANDBOX_STATE, worldSeed, ...overrides };
}
export function addExperience(state, amount) {
    let newExp = state.player.experience + amount;
    let { level, maxHealth, health, maxMana, mana } = state.player;
    // Handle multiple level-ups
    let expToLevel = level * 100;
    while (newExp >= expToLevel) {
        newExp -= expToLevel;
        level += 1;
        maxHealth += 10;
        health = maxHealth;
        maxMana += 5;
        mana = maxMana;
        expToLevel = level * 100;
    }
    return {
        ...state,
        player: {
            ...state.player,
            level,
            experience: newExp,
            maxHealth,
            health,
            maxMana,
            mana,
        },
    };
}
export function addInventoryItem(state, item) {
    const existingIndex = state.inventory.findIndex((i) => i.id === item.id && i.type !== 'weapon' && i.type !== 'armor');
    if (existingIndex >= 0) {
        const inventory = [...state.inventory];
        inventory[existingIndex] = {
            ...inventory[existingIndex],
            quantity: inventory[existingIndex].quantity + item.quantity,
        };
        return { ...state, inventory };
    }
    return {
        ...state,
        inventory: [...state.inventory, item],
    };
}
export function completeQuest(state, questId) {
    const questIndex = state.quests.findIndex((q) => q.id === questId);
    if (questIndex < 0)
        return state;
    const quest = state.quests[questIndex];
    const quests = [...state.quests];
    quests[questIndex] = { ...quest, status: 'completed' };
    let newState = { ...state, quests };
    if (quest.rewards?.experience) {
        newState = addExperience(newState, quest.rewards.experience);
    }
    if (quest.rewards?.gold) {
        newState = { ...newState, gold: newState.gold + quest.rewards.gold };
    }
    return newState;
}
export function unlockLevel(state, levelNumber) {
    if (state.unlockedLevels.includes(levelNumber)) {
        return state;
    }
    return {
        ...state,
        unlockedLevels: [...state.unlockedLevels, levelNumber].sort((a, b) => a - b),
    };
}
export function collectCoin(state, value = 1) {
    const newCoins = state.coins + value;
    const extraLives = Math.floor(newCoins / 100) - Math.floor(state.coins / 100);
    return {
        ...state,
        coins: newCoins % 100,
        lives: Math.min(state.maxLives, state.lives + extraLives),
        score: state.score + value * 10,
    };
}
export function loseLife(state) {
    return {
        ...state,
        lives: Math.max(0, state.lives - 1),
    };
}
export function placeBlock(state, block) {
    const existingIndex = state.blocks.findIndex((b) => b.position.x === block.position.x &&
        b.position.y === block.position.y &&
        b.position.z === block.position.z);
    if (existingIndex >= 0) {
        const blocks = [...state.blocks];
        blocks[existingIndex] = block;
        return { ...state, blocks };
    }
    return {
        ...state,
        blocks: [...state.blocks, block],
    };
}
export function removeBlock(state, position) {
    return {
        ...state,
        blocks: state.blocks.filter((b) => !(b.position.x === position.x &&
            b.position.y === position.y &&
            b.position.z === position.z)),
    };
}
//# sourceMappingURL=state.js.map