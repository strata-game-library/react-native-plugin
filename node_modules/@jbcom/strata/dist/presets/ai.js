/**
 * AI Presets for YukaJS Integration
 *
 * Pre-configured AI behavior patterns for common game entities.
 */
import * as YUKA from 'yuka';
// =============================================================================
// GUARD NPC PRESET
// Patrols waypoints, chases player on sight
// =============================================================================
export function createGuardPreset(config) {
    const { patrolWaypoints, detectionRadius = 15, chaseSpeed = 8, patrolSpeed = 3, maxSpeed = 8, maxForce = 10, mass = 1, } = config;
    // Validate patrol waypoints
    if (!patrolWaypoints || patrolWaypoints.length === 0) {
        throw new Error('GuardPreset requires at least one patrol waypoint');
    }
    const vehicle = new YUKA.Vehicle();
    vehicle.maxSpeed = maxSpeed;
    vehicle.maxForce = maxForce;
    vehicle.mass = mass;
    const path = new YUKA.Path();
    path.loop = true;
    for (const [x, y, z] of patrolWaypoints) {
        path.add(new YUKA.Vector3(x, y, z));
    }
    const followPathBehavior = new YUKA.FollowPathBehavior(path);
    followPathBehavior.active = true;
    const seekBehavior = new YUKA.SeekBehavior();
    seekBehavior.active = false;
    const behaviors = [followPathBehavior, seekBehavior];
    vehicle.steering.add(followPathBehavior);
    vehicle.steering.add(seekBehavior);
    class PatrolState extends YUKA.State {
        enter(entity) {
            entity.maxSpeed = patrolSpeed;
            followPathBehavior.active = true;
            seekBehavior.active = false;
        }
        execute() { }
        exit() { }
    }
    class ChaseState extends YUKA.State {
        enter(entity) {
            entity.maxSpeed = chaseSpeed;
            followPathBehavior.active = false;
            seekBehavior.active = true;
        }
        execute() { }
        exit() { }
    }
    const stateMachine = new YUKA.StateMachine(vehicle);
    const patrolState = new PatrolState();
    const chaseState = new ChaseState();
    stateMachine.currentState = patrolState;
    const update = (_delta, context) => {
        if (context?.playerPosition) {
            const distance = vehicle.position.distanceTo(context.playerPosition);
            if (distance < detectionRadius) {
                if (stateMachine.currentState !== chaseState) {
                    stateMachine.changeTo(chaseState);
                }
                seekBehavior.target = context.playerPosition;
            }
            else {
                if (stateMachine.currentState !== patrolState) {
                    stateMachine.changeTo(patrolState);
                }
            }
        }
        stateMachine.update();
    };
    return {
        vehicle,
        behaviors,
        stateMachine,
        update,
    };
}
// =============================================================================
// PREY ANIMAL PRESET
// Wanders around, flees from threats
// =============================================================================
export function createPreyPreset(config = {}) {
    const { wanderRadius = 2, fleeDistance = 10, fleeSpeed = 10, maxSpeed = 6, maxForce = 8, mass = 1, } = config;
    const vehicle = new YUKA.Vehicle();
    vehicle.maxSpeed = maxSpeed;
    vehicle.maxForce = maxForce;
    vehicle.mass = mass;
    const wanderBehavior = new YUKA.WanderBehavior();
    wanderBehavior.radius = wanderRadius;
    wanderBehavior.distance = 5;
    wanderBehavior.jitter = 3;
    wanderBehavior.active = true;
    const fleeBehavior = new YUKA.FleeBehavior();
    fleeBehavior.panicDistance = fleeDistance;
    fleeBehavior.active = false;
    fleeBehavior.weight = 2;
    const behaviors = [wanderBehavior, fleeBehavior];
    vehicle.steering.add(wanderBehavior);
    vehicle.steering.add(fleeBehavior);
    class WanderState extends YUKA.State {
        enter(entity) {
            entity.maxSpeed = maxSpeed;
            wanderBehavior.active = true;
            fleeBehavior.active = false;
        }
        execute() { }
        exit() { }
    }
    class FleeState extends YUKA.State {
        enter(entity) {
            entity.maxSpeed = fleeSpeed;
            wanderBehavior.active = false;
            fleeBehavior.active = true;
        }
        execute() { }
        exit() { }
    }
    const stateMachine = new YUKA.StateMachine(vehicle);
    const wanderState = new WanderState();
    const fleeState = new FleeState();
    stateMachine.currentState = wanderState;
    const update = (_delta, context) => {
        if (context?.threatPosition) {
            const distance = vehicle.position.distanceTo(context.threatPosition);
            if (distance < fleeDistance) {
                if (stateMachine.currentState !== fleeState) {
                    stateMachine.changeTo(fleeState);
                }
                fleeBehavior.target = context.threatPosition;
            }
            else {
                if (stateMachine.currentState !== wanderState) {
                    stateMachine.changeTo(wanderState);
                }
            }
        }
        stateMachine.update();
    };
    return {
        vehicle,
        behaviors,
        stateMachine,
        update,
    };
}
// =============================================================================
// PREDATOR PRESET
// Patrols area, pursues prey when spotted
// =============================================================================
export function createPredatorPreset(config = {}) {
    const { patrolWaypoints = [], pursuitSpeed = 12, detectionRadius = 20, maxSpeed = 12, maxForce = 15, mass = 2, } = config;
    const vehicle = new YUKA.Vehicle();
    vehicle.maxSpeed = maxSpeed;
    vehicle.maxForce = maxForce;
    vehicle.mass = mass;
    const wanderBehavior = new YUKA.WanderBehavior();
    wanderBehavior.radius = 3;
    wanderBehavior.distance = 8;
    wanderBehavior.jitter = 2;
    let followPathBehavior = null;
    if (patrolWaypoints.length > 0) {
        const path = new YUKA.Path();
        path.loop = true;
        for (const [x, y, z] of patrolWaypoints) {
            path.add(new YUKA.Vector3(x, y, z));
        }
        followPathBehavior = new YUKA.FollowPathBehavior(path);
        followPathBehavior.active = true;
        wanderBehavior.active = false;
    }
    else {
        wanderBehavior.active = true;
    }
    const seekBehavior = new YUKA.SeekBehavior();
    seekBehavior.active = false;
    seekBehavior.weight = 2;
    const behaviors = [wanderBehavior, seekBehavior];
    vehicle.steering.add(wanderBehavior);
    vehicle.steering.add(seekBehavior);
    if (followPathBehavior) {
        behaviors.push(followPathBehavior);
        vehicle.steering.add(followPathBehavior);
    }
    class PatrolState extends YUKA.State {
        enter(entity) {
            entity.maxSpeed = maxSpeed * 0.5;
            seekBehavior.active = false;
            if (followPathBehavior) {
                followPathBehavior.active = true;
                wanderBehavior.active = false;
            }
            else {
                wanderBehavior.active = true;
            }
        }
        execute() { }
        exit() { }
    }
    class PursueState extends YUKA.State {
        enter(entity) {
            entity.maxSpeed = pursuitSpeed;
            wanderBehavior.active = false;
            if (followPathBehavior) {
                followPathBehavior.active = false;
            }
            seekBehavior.active = true;
        }
        execute() { }
        exit() { }
    }
    const stateMachine = new YUKA.StateMachine(vehicle);
    const patrolState = new PatrolState();
    const pursueState = new PursueState();
    stateMachine.currentState = patrolState;
    const update = (_delta, context) => {
        if (context?.preyPosition) {
            const distance = vehicle.position.distanceTo(context.preyPosition);
            if (distance < detectionRadius) {
                if (stateMachine.currentState !== pursueState) {
                    stateMachine.changeTo(pursueState);
                }
                seekBehavior.target = context.preyPosition;
            }
            else {
                if (stateMachine.currentState !== patrolState) {
                    stateMachine.changeTo(patrolState);
                }
            }
        }
        stateMachine.update();
    };
    return {
        vehicle,
        behaviors,
        stateMachine,
        update,
    };
}
// =============================================================================
// FLOCK MEMBER PRESET
// Uses alignment + cohesion + separation for flocking behavior
// =============================================================================
export function createFlockMemberPreset(config = {}) {
    const { separationWeight = 1.5, alignmentWeight = 1.0, cohesionWeight = 1.0, neighborRadius = 10, maxSpeed = 5, maxForce = 8, mass = 1, } = config;
    const vehicle = new YUKA.Vehicle();
    vehicle.maxSpeed = maxSpeed;
    vehicle.maxForce = maxForce;
    vehicle.mass = mass;
    vehicle.updateNeighborhood = true;
    vehicle.neighborhoodRadius = neighborRadius;
    const separationBehavior = new YUKA.SeparationBehavior();
    separationBehavior.weight = separationWeight;
    const alignmentBehavior = new YUKA.AlignmentBehavior();
    alignmentBehavior.weight = alignmentWeight;
    const cohesionBehavior = new YUKA.CohesionBehavior();
    cohesionBehavior.weight = cohesionWeight;
    const wanderBehavior = new YUKA.WanderBehavior();
    wanderBehavior.weight = 0.5;
    wanderBehavior.radius = 1;
    wanderBehavior.distance = 3;
    wanderBehavior.jitter = 1;
    const behaviors = [
        separationBehavior,
        alignmentBehavior,
        cohesionBehavior,
        wanderBehavior,
    ];
    vehicle.steering.add(separationBehavior);
    vehicle.steering.add(alignmentBehavior);
    vehicle.steering.add(cohesionBehavior);
    vehicle.steering.add(wanderBehavior);
    return {
        vehicle,
        behaviors,
    };
}
// =============================================================================
// FOLLOWER PRESET
// Follows a leader at a specific offset
// =============================================================================
export function createFollowerPreset(config = {}) {
    const { offset = [-3, 0, -3], followDistance = 5, maxSpeed = 6, maxForce = 10, mass = 1, } = config;
    const vehicle = new YUKA.Vehicle();
    vehicle.maxSpeed = maxSpeed;
    vehicle.maxForce = maxForce;
    vehicle.mass = mass;
    const arriveBehavior = new YUKA.ArriveBehavior();
    // Use followDistance to influence deceleration and tolerance
    arriveBehavior.deceleration = Math.max(1, followDistance / 2);
    arriveBehavior.tolerance = followDistance * 0.1;
    const behaviors = [arriveBehavior];
    vehicle.steering.add(arriveBehavior);
    const offsetVector = new YUKA.Vector3(offset[0], offset[1], offset[2]);
    const update = (_delta, context) => {
        if (context?.leaderPosition) {
            const targetPosition = context.leaderPosition.clone();
            if (context.leaderRotation) {
                const rotatedOffset = offsetVector.clone();
                rotatedOffset.applyRotation(context.leaderRotation);
                targetPosition.add(rotatedOffset);
            }
            else {
                targetPosition.add(offsetVector);
            }
            arriveBehavior.target = targetPosition;
        }
    };
    return {
        vehicle,
        behaviors,
        update,
    };
}
export function createFlock(config) {
    const { count, spawnArea = { min: [-10, 0, -10], max: [10, 0, 10] }, ...memberConfig } = config;
    const members = [];
    for (let i = 0; i < count; i++) {
        const member = createFlockMemberPreset(memberConfig);
        member.vehicle.position.set(spawnArea.min[0] + Math.random() * (spawnArea.max[0] - spawnArea.min[0]), spawnArea.min[1] + Math.random() * (spawnArea.max[1] - spawnArea.min[1]), spawnArea.min[2] + Math.random() * (spawnArea.max[2] - spawnArea.min[2]));
        members.push(member);
    }
    return members;
}
//# sourceMappingURL=ai.js.map