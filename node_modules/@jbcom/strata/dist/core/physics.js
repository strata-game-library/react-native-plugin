/**
 * Core Physics Utilities
 *
 * Pure TypeScript physics helper functions and type definitions
 * for use with @react-three/rapier.
 * @module core/physics
 */
import * as THREE from 'three';
/**
 * Collision layer bitmask definitions
 */
export var CollisionLayer;
(function (CollisionLayer) {
    CollisionLayer[CollisionLayer["Default"] = 1] = "Default";
    CollisionLayer[CollisionLayer["Static"] = 2] = "Static";
    CollisionLayer[CollisionLayer["Dynamic"] = 4] = "Dynamic";
    CollisionLayer[CollisionLayer["Character"] = 8] = "Character";
    CollisionLayer[CollisionLayer["Vehicle"] = 16] = "Vehicle";
    CollisionLayer[CollisionLayer["Projectile"] = 32] = "Projectile";
    CollisionLayer[CollisionLayer["Trigger"] = 64] = "Trigger";
    CollisionLayer[CollisionLayer["Debris"] = 128] = "Debris";
    CollisionLayer[CollisionLayer["Water"] = 256] = "Water";
    CollisionLayer[CollisionLayer["All"] = 65535] = "All";
})(CollisionLayer || (CollisionLayer = {}));
export const collisionFilters = {
    default: {
        memberships: CollisionLayer.Default,
        filter: CollisionLayer.All,
    },
    static: {
        memberships: CollisionLayer.Static,
        filter: CollisionLayer.All,
    },
    character: {
        memberships: CollisionLayer.Character,
        filter: CollisionLayer.Static |
            CollisionLayer.Dynamic |
            CollisionLayer.Trigger |
            CollisionLayer.Water,
    },
    vehicle: {
        memberships: CollisionLayer.Vehicle,
        filter: CollisionLayer.Static | CollisionLayer.Dynamic | CollisionLayer.Character,
    },
    projectile: {
        memberships: CollisionLayer.Projectile,
        filter: CollisionLayer.Static |
            CollisionLayer.Dynamic |
            CollisionLayer.Character |
            CollisionLayer.Vehicle,
    },
    debris: {
        memberships: CollisionLayer.Debris,
        filter: CollisionLayer.Static | CollisionLayer.Dynamic,
    },
    trigger: {
        memberships: CollisionLayer.Trigger,
        filter: CollisionLayer.Character | CollisionLayer.Vehicle,
    },
    water: {
        memberships: CollisionLayer.Water,
        filter: CollisionLayer.Character |
            CollisionLayer.Dynamic |
            CollisionLayer.Vehicle |
            CollisionLayer.Debris,
    },
};
/**
 * Calculate an impulse to apply based on desired velocity change
 * @param currentVelocity - Current velocity vector
 * @param targetVelocity - Target velocity vector
 * @param mass - Object mass
 * @returns Impulse vector to apply
 */
export function calculateImpulse(currentVelocity, targetVelocity, mass) {
    const deltaV = targetVelocity.clone().sub(currentVelocity);
    return deltaV.multiplyScalar(mass);
}
/**
 * Calculate continuous force to achieve target velocity
 * @param currentVelocity - Current velocity
 * @param targetVelocity - Target velocity
 * @param mass - Object mass
 * @param deltaTime - Time step
 * @returns Force vector to apply
 */
export function calculateForce(currentVelocity, targetVelocity, mass, deltaTime) {
    const impulse = calculateImpulse(currentVelocity, targetVelocity, mass);
    return impulse.divideScalar(deltaTime);
}
/**
 * Calculate jump impulse for character controllers
 * @param jumpHeight - Desired jump height
 * @param gravity - Gravity magnitude
 * @param mass - Character mass
 * @returns Upward impulse magnitude
 */
export function calculateJumpImpulse(jumpHeight, gravity, mass) {
    return Math.sqrt(2 * Math.abs(gravity) * jumpHeight) * mass;
}
/**
 * Calculate landing velocity from fall height
 * @param fallHeight - Height of the fall
 * @param gravity - Gravity magnitude
 * @returns Landing velocity magnitude
 */
export function calculateLandingVelocity(fallHeight, gravity) {
    return Math.sqrt(2 * Math.abs(gravity) * fallHeight);
}
/**
 * Apply drag force to velocity
 * @param velocity - Current velocity
 * @param dragCoefficient - Drag coefficient
 * @param deltaTime - Time step
 * @returns New velocity after drag
 */
export function applyDrag(velocity, dragCoefficient, deltaTime) {
    const dragFactor = 1 - dragCoefficient * deltaTime;
    return velocity.clone().multiplyScalar(Math.max(0, dragFactor));
}
/**
 * Calculate buoyancy force for a submerged point
 * @param depth - Depth below water surface (positive = submerged)
 * @param buoyancyStrength - Strength multiplier
 * @param mass - Object mass
 * @returns Upward buoyancy force magnitude
 */
export function calculateBuoyancyForce(depth, buoyancyStrength, mass) {
    if (depth <= 0)
        return 0;
    return depth * buoyancyStrength * mass;
}
/**
 * Calculate slope angle from surface normal
 * @param normal - Surface normal vector
 * @returns Slope angle in radians
 */
export function calculateSlopeAngle(normal) {
    const up = new THREE.Vector3(0, 1, 0);
    return Math.acos(Math.min(1, Math.max(-1, normal.dot(up))));
}
/**
 * Check if slope is walkable
 * @param normal - Surface normal vector
 * @param maxSlopeAngle - Maximum walkable slope angle in radians
 * @returns Whether the slope can be walked on
 */
export function isWalkableSlope(normal, maxSlopeAngle) {
    return calculateSlopeAngle(normal) <= maxSlopeAngle;
}
/**
 * Project velocity onto ground plane
 * @param velocity - Input velocity
 * @param groundNormal - Ground surface normal
 * @returns Velocity projected onto ground plane
 */
export function projectVelocityOntoGround(velocity, groundNormal) {
    const dot = velocity.dot(groundNormal);
    return velocity.clone().sub(groundNormal.clone().multiplyScalar(dot));
}
/**
 * Calculate steering force for vehicle physics
 * @param currentDirection - Current forward direction
 * @param targetDirection - Target direction
 * @param maxSteerAngle - Maximum steering angle
 * @returns Steering angle to apply
 */
export function calculateSteeringAngle(currentDirection, targetDirection, maxSteerAngle) {
    const cross = new THREE.Vector3().crossVectors(currentDirection, targetDirection);
    const angle = Math.atan2(cross.y, currentDirection.dot(targetDirection));
    return Math.max(-maxSteerAngle, Math.min(maxSteerAngle, angle));
}
/**
 * Calculate suspension force using spring-damper model
 * @param compression - Current suspension compression (0-1)
 * @param velocity - Vertical velocity
 * @param stiffness - Spring stiffness
 * @param damping - Damping coefficient
 * @returns Suspension force magnitude
 */
export function calculateSuspensionForce(compression, velocity, stiffness, damping) {
    const springForce = compression * stiffness;
    const damperForce = -velocity * damping;
    return springForce + damperForce;
}
/**
 * Calculate explosion impulse falloff
 * @param distance - Distance from explosion center
 * @param explosionRadius - Explosion radius
 * @param maxForce - Maximum force at center
 * @returns Force at given distance
 */
export function calculateExplosionForce(distance, explosionRadius, maxForce) {
    if (distance >= explosionRadius)
        return 0;
    const falloff = 1 - distance / explosionRadius;
    return maxForce * falloff * falloff;
}
/**
 * Generate random debris velocity for destructible objects
 * @param explosionCenter - Center of explosion
 * @param debrisPosition - Position of debris piece
 * @param baseForce - Base explosion force
 * @param randomness - Randomness factor (0-1)
 * @returns Velocity vector for debris
 */
export function generateDebrisVelocity(explosionCenter, debrisPosition, baseForce, randomness = 0.3) {
    const direction = debrisPosition.clone().sub(explosionCenter).normalize();
    const force = baseForce * (1 + (Math.random() - 0.5) * randomness);
    direction.x += (Math.random() - 0.5) * randomness;
    direction.y += Math.random() * randomness * 0.5;
    direction.z += (Math.random() - 0.5) * randomness;
    return direction.normalize().multiplyScalar(force);
}
/**
 * Create default physics configuration
 * @returns Default physics config
 */
export function createDefaultPhysicsConfig() {
    return {
        gravity: [0, -9.81, 0],
        timeStep: 1 / 60,
        maxStabilizationIterations: 1,
        maxVelocityIterations: 4,
        maxVelocityFrictionIterations: 8,
        erp: 0.8,
        allowedLinearError: 0.001,
        predictionDistance: 0.002,
    };
}
/**
 * Create default character controller configuration
 * @returns Default character controller config
 */
export function createDefaultCharacterConfig() {
    return {
        capsuleRadius: 0.3,
        capsuleHeight: 1.8,
        mass: 80,
        maxSpeed: 6,
        acceleration: 30,
        deceleration: 20,
        jumpForce: 8,
        maxJumps: 1,
        groundCheckDistance: 0.1,
        slopeLimit: Math.PI / 4,
        stepHeight: 0.35,
        coyoteTime: 0.15,
        jumpBufferTime: 0.1,
        airControl: 0.3,
        gravityScale: 2,
        snapToGroundDistance: 0.3,
        skinWidth: 0.02,
        autoStepEnabled: true,
        slideEnabled: true,
    };
}
/**
 * Create default vehicle configuration
 * @returns Default vehicle config
 */
export function createDefaultVehicleConfig() {
    return {
        chassisMass: 1500,
        chassisSize: [2, 0.8, 4.5],
        wheelRadius: 0.35,
        wheelWidth: 0.25,
        wheelPositions: [
            [-0.85, -0.3, 1.4],
            [0.85, -0.3, 1.4],
            [-0.85, -0.3, -1.3],
            [0.85, -0.3, -1.3],
        ],
        suspensionRestLength: 0.3,
        suspensionStiffness: 30,
        suspensionDamping: 4.5,
        suspensionTravel: 0.25,
        maxSteerAngle: Math.PI / 6,
        driveWheels: 'rear',
        motorForce: 8000,
        brakeForce: 5000,
        frictionSlip: 2,
        rollInfluence: 0.1,
        antiRoll: 0.5,
        centerOfMassOffset: [0, -0.3, 0],
    };
}
/**
 * Create a humanoid ragdoll configuration
 * @param scale - Scale factor for the ragdoll
 * @returns Ragdoll configuration
 */
export function createHumanoidRagdoll(scale = 1) {
    const s = scale;
    return {
        bodyParts: [
            {
                name: 'pelvis',
                type: 'box',
                size: [0.25 * s, 0.2 * s, 0.15 * s],
                position: [0, 1 * s, 0],
                mass: 10,
            },
            {
                name: 'torso',
                type: 'box',
                size: [0.25 * s, 0.3 * s, 0.12 * s],
                position: [0, 1.35 * s, 0],
                mass: 15,
            },
            {
                name: 'chest',
                type: 'box',
                size: [0.28 * s, 0.25 * s, 0.14 * s],
                position: [0, 1.65 * s, 0],
                mass: 15,
            },
            { name: 'head', type: 'sphere', size: [0.12 * s], position: [0, 1.95 * s, 0], mass: 5 },
            {
                name: 'upperArmL',
                type: 'capsule',
                size: [0.05 * s, 0.25 * s],
                position: [-0.35 * s, 1.6 * s, 0],
                rotation: [0, 0, Math.PI / 2],
                mass: 3,
            },
            {
                name: 'upperArmR',
                type: 'capsule',
                size: [0.05 * s, 0.25 * s],
                position: [0.35 * s, 1.6 * s, 0],
                rotation: [0, 0, -Math.PI / 2],
                mass: 3,
            },
            {
                name: 'forearmL',
                type: 'capsule',
                size: [0.04 * s, 0.23 * s],
                position: [-0.6 * s, 1.6 * s, 0],
                rotation: [0, 0, Math.PI / 2],
                mass: 2,
            },
            {
                name: 'forearmR',
                type: 'capsule',
                size: [0.04 * s, 0.23 * s],
                position: [0.6 * s, 1.6 * s, 0],
                rotation: [0, 0, -Math.PI / 2],
                mass: 2,
            },
            {
                name: 'thighL',
                type: 'capsule',
                size: [0.07 * s, 0.35 * s],
                position: [-0.1 * s, 0.65 * s, 0],
                mass: 6,
            },
            {
                name: 'thighR',
                type: 'capsule',
                size: [0.07 * s, 0.35 * s],
                position: [0.1 * s, 0.65 * s, 0],
                mass: 6,
            },
            {
                name: 'calfL',
                type: 'capsule',
                size: [0.05 * s, 0.35 * s],
                position: [-0.1 * s, 0.25 * s, 0],
                mass: 4,
            },
            {
                name: 'calfR',
                type: 'capsule',
                size: [0.05 * s, 0.35 * s],
                position: [0.1 * s, 0.25 * s, 0],
                mass: 4,
            },
        ],
        joints: [
            {
                parent: 'pelvis',
                child: 'torso',
                type: 'spherical',
                anchor1: [0, 0.1 * s, 0],
                anchor2: [0, -0.15 * s, 0],
                limits: { min: -0.3, max: 0.3 },
            },
            {
                parent: 'torso',
                child: 'chest',
                type: 'spherical',
                anchor1: [0, 0.15 * s, 0],
                anchor2: [0, -0.125 * s, 0],
                limits: { min: -0.3, max: 0.3 },
            },
            {
                parent: 'chest',
                child: 'head',
                type: 'spherical',
                anchor1: [0, 0.125 * s, 0],
                anchor2: [0, -0.1 * s, 0],
                limits: { min: -0.5, max: 0.5 },
            },
            {
                parent: 'chest',
                child: 'upperArmL',
                type: 'spherical',
                anchor1: [-0.18 * s, 0.08 * s, 0],
                anchor2: [0.125 * s, 0, 0],
                limits: { min: -1.5, max: 1.5 },
            },
            {
                parent: 'chest',
                child: 'upperArmR',
                type: 'spherical',
                anchor1: [0.18 * s, 0.08 * s, 0],
                anchor2: [-0.125 * s, 0, 0],
                limits: { min: -1.5, max: 1.5 },
            },
            {
                parent: 'upperArmL',
                child: 'forearmL',
                type: 'revolute',
                anchor1: [-0.125 * s, 0, 0],
                anchor2: [0.115 * s, 0, 0],
                axis: [0, 1, 0],
                limits: { min: 0, max: 2.5 },
            },
            {
                parent: 'upperArmR',
                child: 'forearmR',
                type: 'revolute',
                anchor1: [0.125 * s, 0, 0],
                anchor2: [-0.115 * s, 0, 0],
                axis: [0, 1, 0],
                limits: { min: -2.5, max: 0 },
            },
            {
                parent: 'pelvis',
                child: 'thighL',
                type: 'spherical',
                anchor1: [-0.1 * s, -0.1 * s, 0],
                anchor2: [0, 0.175 * s, 0],
                limits: { min: -1.2, max: 1.2 },
            },
            {
                parent: 'pelvis',
                child: 'thighR',
                type: 'spherical',
                anchor1: [0.1 * s, -0.1 * s, 0],
                anchor2: [0, 0.175 * s, 0],
                limits: { min: -1.2, max: 1.2 },
            },
            {
                parent: 'thighL',
                child: 'calfL',
                type: 'revolute',
                anchor1: [0, -0.175 * s, 0],
                anchor2: [0, 0.175 * s, 0],
                axis: [1, 0, 0],
                limits: { min: -2.5, max: 0 },
            },
            {
                parent: 'thighR',
                child: 'calfR',
                type: 'revolute',
                anchor1: [0, -0.175 * s, 0],
                anchor2: [0, 0.175 * s, 0],
                axis: [1, 0, 0],
                limits: { min: -2.5, max: 0 },
            },
        ],
        linearDamping: 0.4,
        angularDamping: 0.8,
        enableSelfCollision: false,
        sleepThreshold: 0.2,
    };
}
/**
 * Create default destructible configuration
 * @returns Default destructible config
 */
export function createDefaultDestructibleConfig() {
    return {
        health: 100,
        breakForce: 50,
        shardCount: 8,
        shardScale: [0.3, 0.3, 0.3],
        explosionForce: 5,
        explosionRadius: 2,
        shardLifetime: 3,
        shardMass: 0.5,
        shardAngularVelocity: [5, 5, 5],
    };
}
/**
 * Create default buoyancy configuration
 * @returns Default buoyancy config
 */
export function createDefaultBuoyancyConfig() {
    return {
        waterLevel: 0,
        buoyancyForce: 15,
        waterDrag: 3,
        waterAngularDrag: 2,
        voxelResolution: 0.5,
        samplePointCount: 8,
        dynamicWater: false,
    };
}
//# sourceMappingURL=physics.js.map