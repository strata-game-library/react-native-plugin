/**
 * Core UI Utilities
 *
 * Provides types, configurations, and helper functions for game UI elements.
 * Pure TypeScript implementation with no React dependencies.
 */
import * as THREE from 'three';
export function getAnchorOffset(anchor, width, height) {
    switch (anchor) {
        case 'topLeft':
            return { x: 0, y: 0 };
        case 'topRight':
            return { x: -width, y: 0 };
        case 'bottomLeft':
            return { x: 0, y: -height };
        case 'bottomRight':
            return { x: -width, y: -height };
        case 'center':
            return { x: -width / 2, y: -height / 2 };
        case 'top':
            return { x: -width / 2, y: 0 };
        case 'bottom':
            return { x: -width / 2, y: -height };
        case 'left':
            return { x: 0, y: -height / 2 };
        case 'right':
            return { x: -width, y: -height / 2 };
        default:
            return { x: 0, y: 0 };
    }
}
export function worldToScreen(position, camera, width, height) {
    const vector = position.clone();
    vector.project(camera);
    const behindCamera = vector.z > 1;
    const x = (vector.x * 0.5 + 0.5) * width;
    const y = (-vector.y * 0.5 + 0.5) * height;
    const visible = !behindCamera && x >= 0 && x <= width && y >= 0 && y <= height;
    const distance = position.distanceTo(camera.position);
    return { x, y, visible, distance };
}
export function screenToWorld(screenX, screenY, camera, width, height, targetZ = 0) {
    const vector = new THREE.Vector3((screenX / width) * 2 - 1, -(screenY / height) * 2 + 1, 0.5);
    vector.unproject(camera);
    const dir = vector.sub(camera.position).normalize();
    // Guard against division by zero when camera ray is parallel to XY plane
    if (Math.abs(dir.z) < 0.000001) {
        // Return a point at a reasonable distance along the ray
        return camera.position.clone().add(dir.multiplyScalar(100));
    }
    const distance = (targetZ - camera.position.z) / dir.z;
    return camera.position.clone().add(dir.multiplyScalar(distance));
}
export function calculateFade(distance, fadeStart, fadeEnd) {
    if (distance <= fadeStart)
        return 1;
    if (distance >= fadeEnd)
        return 0;
    // Guard against division by zero when fadeStart equals fadeEnd
    if (fadeEnd === fadeStart)
        return 1;
    return 1 - (distance - fadeStart) / (fadeEnd - fadeStart);
}
export function formatProgressText(value, maxValue, format) {
    switch (format) {
        case 'percentage':
            // Guard against division by zero when maxValue is zero
            return maxValue === 0 ? '0%' : `${Math.round((value / maxValue) * 100)}%`;
        case 'fraction':
            return `${Math.round(value)}/${Math.round(maxValue)}`;
        case 'value':
            return `${Math.round(value)}`;
        default:
            return '';
    }
}
export function clampProgress(value, maxValue) {
    return Math.max(0, Math.min(value, maxValue));
}
export function lerp(start, end, t) {
    return start + (end - start) * t;
}
export function easeOutCubic(t) {
    return 1 - (1 - t) ** 3;
}
export function easeOutElastic(t) {
    const c4 = (2 * Math.PI) / 3;
    return t === 0 ? 0 : t === 1 ? 1 : 2 ** (-10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
}
export function getTextDirection(text) {
    const rtlChars = /[\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/;
    return rtlChars.test(text) ? 'rtl' : 'ltr';
}
export function createDefaultProgressBar() {
    return {
        value: 100,
        maxValue: 100,
        width: 100,
        height: 10,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        fillColor: '#4ade80',
        borderColor: 'rgba(255, 255, 255, 0.3)',
        borderWidth: 1,
        borderRadius: 2,
        showText: false,
        textFormat: 'percentage',
        animationDuration: 300,
    };
}
export function createDefaultInventory(columns = 6, rows = 4) {
    const slots = [];
    for (let i = 0; i < columns * rows; i++) {
        slots.push({ id: `slot-${i}` });
    }
    return {
        slots,
        columns,
        rows,
        slotSize: 48,
        slotGap: 4,
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        slotBackgroundColor: 'rgba(50, 50, 50, 0.8)',
        slotBorderColor: 'rgba(100, 100, 100, 0.5)',
        selectedSlotBorderColor: '#d4af37',
        showTooltips: true,
        allowDrag: true,
        showQuantity: true,
        rarityColors: {
            common: '#9ca3af',
            uncommon: '#22c55e',
            rare: '#3b82f6',
            epic: '#a855f7',
            legendary: '#f59e0b',
        },
    };
}
export function createDefaultDialog() {
    return {
        lines: [],
        currentLine: 0,
        typewriterSpeed: 30,
        textColor: '#ffffff',
        backgroundColor: 'rgba(0, 0, 0, 0.85)',
        speakerColor: '#d4af37',
        fontSize: 16,
        fontFamily: 'system-ui, -apple-system, sans-serif',
        textDirection: 'auto',
        showSpeakerImage: true,
        imagePosition: 'left',
        continueIndicator: '▼',
        skipEnabled: true,
        padding: 20,
        maxWidth: 600,
        position: 'bottom',
    };
}
export function createDefaultTooltip() {
    return {
        backgroundColor: 'rgba(20, 20, 20, 0.95)',
        borderColor: 'rgba(100, 100, 100, 0.5)',
        textColor: '#ffffff',
        maxWidth: 250,
        fontSize: 14,
        padding: 12,
        showDelay: 200,
        hideDelay: 0,
    };
}
export function createDefaultNotification() {
    return {
        message: '',
        type: 'info',
        duration: 5000,
        position: 'topRight',
        dismissible: true,
        progress: true,
        backgroundColor: 'rgba(20, 20, 20, 0.95)',
        textColor: '#ffffff',
        animationIn: 'slideIn',
        animationOut: 'fadeOut',
    };
}
export function createDefaultMinimap() {
    return {
        size: 150,
        zoom: 1,
        rotation: 0,
        followPlayer: true,
        rotateWithPlayer: false,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        borderColor: 'rgba(255, 255, 255, 0.3)',
        borderWidth: 2,
        borderRadius: 75,
        playerColor: '#4ade80',
        playerSize: 8,
        fogOfWar: false,
        showCompass: true,
    };
}
export function createDefaultCrosshair() {
    return {
        type: 'cross',
        size: 20,
        thickness: 2,
        gap: 4,
        color: '#ffffff',
        outlineColor: '#000000',
        outlineWidth: 1,
        opacity: 0.8,
        dot: true,
        dotSize: 2,
        dynamic: false,
        spreadMultiplier: 1,
    };
}
export function createDefaultDamageNumber() {
    return {
        value: 0,
        type: 'normal',
        color: '#ffffff',
        fontSize: 24,
        fontFamily: 'Impact, sans-serif',
        fontWeight: 'bold',
        duration: 1500,
        floatDistance: 60,
        fadeStart: 0.5,
        scale: 1,
        randomOffset: 20,
    };
}
export function createDefaultNameplate() {
    return {
        name: 'Unknown',
        nameColor: '#ffffff',
        titleColor: '#a8a29e',
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        showHealthBar: true,
        showLevel: true,
        fadeStart: 15,
        fadeEnd: 25,
    };
}
export function getDamageNumberColor(type) {
    switch (type) {
        case 'critical':
            return '#ff6b6b';
        case 'heal':
            return '#4ade80';
        case 'miss':
            return '#9ca3af';
        case 'block':
            return '#60a5fa';
        default:
            return '#ffffff';
    }
}
export function formatNumber(value) {
    if (value >= 1000000) {
        return `${(value / 1000000).toFixed(1)}M`;
    }
    if (value >= 1000) {
        return `${(value / 1000).toFixed(1)}K`;
    }
    return Math.round(value).toString();
}
export function getNotificationIcon(type) {
    switch (type) {
        case 'success':
            return '✓';
        case 'warning':
            return '⚠';
        case 'error':
            return '✕';
        default:
            return 'ℹ';
    }
}
export function getNotificationColor(type) {
    switch (type) {
        case 'success':
            return '#4ade80';
        case 'warning':
            return '#fbbf24';
        case 'error':
            return '#ef4444';
        default:
            return '#60a5fa';
    }
}
//# sourceMappingURL=ui.js.map