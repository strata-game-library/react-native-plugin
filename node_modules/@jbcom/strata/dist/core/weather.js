/**
 * Core Weather System
 *
 * Provides weather state management, transitions, and environmental simulation.
 */
import * as THREE from 'three';
export class WeatherSystem {
    currentState;
    transition = null;
    listeners = [];
    constructor(initialState = {}) {
        this.currentState = {
            type: 'clear',
            intensity: 0,
            windDirection: new THREE.Vector3(1, 0, 0),
            windIntensity: 0,
            temperature: 20,
            visibility: 1,
            cloudCoverage: 0,
            precipitationRate: 0,
            ...initialState,
        };
    }
    getState() {
        return { ...this.currentState };
    }
    transitionTo(targetState, duration = 5) {
        const to = {
            ...this.currentState,
            ...targetState,
        };
        this.transition = {
            from: { ...this.currentState },
            to,
            duration,
            elapsed: 0,
        };
    }
    update(deltaTime) {
        if (!this.transition)
            return;
        this.transition.elapsed += deltaTime;
        const progress = Math.min(this.transition.elapsed / this.transition.duration, 1);
        const t = smoothStep(progress);
        this.currentState = blendWeatherStates(this.transition.from, this.transition.to, t);
        if (progress >= 1) {
            this.currentState = { ...this.transition.to };
            this.transition = null;
        }
        this.notifyListeners();
    }
    setImmediate(state) {
        this.transition = null;
        this.currentState = {
            ...this.currentState,
            ...state,
        };
        this.notifyListeners();
    }
    isTransitioning() {
        return this.transition !== null;
    }
    getTransitionProgress() {
        if (!this.transition)
            return 1;
        return Math.min(this.transition.elapsed / this.transition.duration, 1);
    }
    subscribe(listener) {
        this.listeners.push(listener);
        return () => {
            this.listeners = this.listeners.filter((l) => l !== listener);
        };
    }
    notifyListeners() {
        const state = this.getState();
        for (const listener of this.listeners) {
            listener(state);
        }
    }
    getPrecipitationType() {
        if (this.currentState.type === 'clear' || this.currentState.type === 'fog') {
            return 'none';
        }
        if (this.currentState.temperature <= 0) {
            return 'snow';
        }
        return 'rain';
    }
    shouldShowLightning() {
        return this.currentState.type === 'storm' && this.currentState.intensity > 0.5;
    }
    getWindVector() {
        return this.currentState.windDirection
            .clone()
            .normalize()
            .multiplyScalar(this.currentState.windIntensity);
    }
}
function smoothStep(t) {
    return t * t * (3 - 2 * t);
}
function blendWeatherStates(from, to, t) {
    return {
        type: t < 0.5 ? from.type : to.type,
        intensity: lerp(from.intensity, to.intensity, t),
        windDirection: new THREE.Vector3().lerpVectors(from.windDirection, to.windDirection, t),
        windIntensity: lerp(from.windIntensity, to.windIntensity, t),
        temperature: lerp(from.temperature, to.temperature, t),
        visibility: lerp(from.visibility, to.visibility, t),
        cloudCoverage: lerp(from.cloudCoverage, to.cloudCoverage, t),
        precipitationRate: lerp(from.precipitationRate, to.precipitationRate, t),
    };
}
function lerp(a, b, t) {
    return a + (b - a) * t;
}
export function createWeatherSystem(initialState) {
    return new WeatherSystem(initialState);
}
export class WindSimulation {
    config;
    time = 0;
    currentGust = 0;
    constructor(config = {}) {
        this.config = {
            direction: new THREE.Vector3(1, 0, 0.2).normalize(),
            intensity: 1,
            gustFrequency: 0.5,
            gustIntensity: 0.3,
            ...config,
        };
    }
    update(deltaTime) {
        this.time += deltaTime;
        const gustPhase = this.time * this.config.gustFrequency * Math.PI * 2;
        this.currentGust = (Math.sin(gustPhase) * 0.5 + 0.5) * this.config.gustIntensity;
    }
    getWindVector() {
        const totalIntensity = this.config.intensity + this.currentGust;
        return this.config.direction.clone().multiplyScalar(totalIntensity);
    }
    setDirection(direction) {
        this.config.direction = direction.clone().normalize();
    }
    setIntensity(intensity) {
        this.config.intensity = intensity;
    }
    getConfig() {
        return { ...this.config };
    }
}
export function createWindSimulation(config) {
    return new WindSimulation(config);
}
export function calculateTemperature(config) {
    const altitudeEffect = -config.altitude * config.lapseRate * 0.0065;
    const normalizedTime = (config.timeOfDay / 24) * Math.PI * 2;
    const timeEffect = Math.sin(normalizedTime - Math.PI / 2) * 5;
    const seasonEffect = Math.cos((config.season / 12) * Math.PI * 2) * 15;
    return config.baseTemperature + altitudeEffect + timeEffect + seasonEffect;
}
export function getPrecipitationType(temperature) {
    if (temperature <= -2)
        return 'snow';
    if (temperature <= 2)
        return 'sleet';
    return 'rain';
}
//# sourceMappingURL=weather.js.map