/**
 * Core Input System
 *
 * Pure TypeScript input handling with unified pointer, touch, gamepad events.
 * Provides normalized axis/force outputs, haptic feedback, and drag state machine.
 */
import * as THREE from 'three';
export class InputStateMachine {
    state = 'idle';
    stateStartTime = 0;
    dragThreshold = 5;
    startPosition = new THREE.Vector2();
    releaseTimeoutId = null;
    constructor(dragThreshold = 5) {
        this.dragThreshold = dragThreshold;
    }
    getState() {
        return this.state;
    }
    getStateDuration() {
        return Date.now() - this.stateStartTime;
    }
    press(position) {
        this.state = 'pressed';
        this.stateStartTime = Date.now();
        this.startPosition.copy(position);
    }
    move(position) {
        if (this.state === 'pressed') {
            const distance = position.distanceTo(this.startPosition);
            if (distance > this.dragThreshold) {
                this.state = 'dragging';
                this.stateStartTime = Date.now();
            }
        }
    }
    release() {
        // Clear any existing timeout to prevent race conditions
        if (this.releaseTimeoutId !== null) {
            clearTimeout(this.releaseTimeoutId);
        }
        this.state = 'released';
        this.stateStartTime = Date.now();
        this.releaseTimeoutId = setTimeout(() => {
            if (this.state === 'released') {
                this.state = 'idle';
                this.stateStartTime = Date.now();
            }
            this.releaseTimeoutId = null;
        }, 100);
    }
    reset() {
        // Clear any pending timeout on reset
        if (this.releaseTimeoutId !== null) {
            clearTimeout(this.releaseTimeoutId);
            this.releaseTimeoutId = null;
        }
        this.state = 'idle';
        this.stateStartTime = Date.now();
    }
}
export class HapticFeedback {
    enabled = true;
    lastVibration = 0;
    minInterval = 50;
    constructor(enabled = true) {
        this.enabled = enabled && this.isSupported();
    }
    isSupported() {
        return typeof navigator !== 'undefined' && 'vibrate' in navigator;
    }
    setEnabled(enabled) {
        this.enabled = enabled && this.isSupported();
    }
    vibrate(pattern) {
        if (!this.enabled)
            return false;
        const now = Date.now();
        if (now - this.lastVibration < this.minInterval)
            return false;
        this.lastVibration = now;
        try {
            return navigator.vibrate(pattern);
        }
        catch {
            return false;
        }
    }
    pulse(duration = 50) {
        return this.vibrate(duration);
    }
    doublePulse() {
        return this.vibrate([30, 50, 30]);
    }
    heavyImpact() {
        return this.vibrate([100]);
    }
    lightImpact() {
        return this.vibrate([20]);
    }
    selection() {
        return this.vibrate([10]);
    }
    error() {
        return this.vibrate([50, 100, 50, 100, 50]);
    }
    success() {
        return this.vibrate([30, 80, 100]);
    }
    stop() {
        if (this.isSupported()) {
            navigator.vibrate(0);
        }
    }
}
export class InputManager {
    config;
    stateMachine;
    haptics;
    pointerState;
    gamepadState;
    listeners;
    animationFrameId = null;
    element = null;
    constructor(config = {}) {
        this.config = {
            deadzone: config.deadzone ?? 0.1,
            maxDistance: config.maxDistance ?? 100,
            hapticEnabled: config.hapticEnabled ?? true,
            gamepadIndex: config.gamepadIndex ?? 0,
        };
        this.stateMachine = new InputStateMachine();
        this.haptics = new HapticFeedback(this.config.hapticEnabled);
        this.listeners = new Map();
        this.pointerState = {
            isDown: false,
            startPosition: new THREE.Vector2(),
            currentPosition: new THREE.Vector2(),
            delta: new THREE.Vector2(),
            force: 0,
        };
        this.gamepadState = {
            connected: false,
            axes: [0, 0, 0, 0],
            buttons: [],
            timestamp: 0,
        };
    }
    attach(element) {
        this.element = element;
        element.addEventListener('pointerdown', this.handlePointerDown);
        element.addEventListener('pointermove', this.handlePointerMove);
        element.addEventListener('pointerup', this.handlePointerUp);
        element.addEventListener('pointercancel', this.handlePointerUp);
        element.addEventListener('touchstart', this.handleTouchStart, { passive: false });
        element.addEventListener('touchmove', this.handleTouchMove, { passive: false });
        element.addEventListener('touchend', this.handleTouchEnd);
        if (typeof window !== 'undefined') {
            window.addEventListener('gamepadconnected', this.handleGamepadConnected);
            window.addEventListener('gamepaddisconnected', this.handleGamepadDisconnected);
        }
        this.startGamepadPolling();
    }
    detach() {
        if (this.element) {
            this.element.removeEventListener('pointerdown', this.handlePointerDown);
            this.element.removeEventListener('pointermove', this.handlePointerMove);
            this.element.removeEventListener('pointerup', this.handlePointerUp);
            this.element.removeEventListener('pointercancel', this.handlePointerUp);
            this.element.removeEventListener('touchstart', this.handleTouchStart);
            this.element.removeEventListener('touchmove', this.handleTouchMove);
            this.element.removeEventListener('touchend', this.handleTouchEnd);
            this.element = null;
        }
        if (typeof window !== 'undefined') {
            window.removeEventListener('gamepadconnected', this.handleGamepadConnected);
            window.removeEventListener('gamepaddisconnected', this.handleGamepadDisconnected);
        }
        this.stopGamepadPolling();
    }
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        this.listeners.get(event)?.add(callback);
    }
    off(event, callback) {
        this.listeners.get(event)?.delete(callback);
    }
    emit(type, axis, force, worldPosition) {
        const event = {
            type,
            axis,
            force,
            worldPosition,
            timestamp: Date.now(),
        };
        this.listeners.get(type)?.forEach((callback) => callback(event));
        this.listeners.get('*')?.forEach((callback) => callback(event));
    }
    handlePointerDown = (e) => {
        this.pointerState.isDown = true;
        this.pointerState.startPosition.set(e.clientX, e.clientY);
        this.pointerState.currentPosition.set(e.clientX, e.clientY);
        this.pointerState.delta.set(0, 0);
        this.pointerState.force = e.pressure ?? 1;
        this.stateMachine.press(this.pointerState.startPosition);
        this.haptics.lightImpact();
        this.emit('press', { x: 0, y: 0 }, this.pointerState.force, new THREE.Vector3());
    };
    handlePointerMove = (e) => {
        if (!this.pointerState.isDown)
            return;
        this.pointerState.currentPosition.set(e.clientX, e.clientY);
        this.pointerState.delta.subVectors(this.pointerState.currentPosition, this.pointerState.startPosition);
        this.pointerState.force = e.pressure ?? 1;
        this.stateMachine.move(this.pointerState.currentPosition);
        const axis = this.normalizeAxis(this.pointerState.delta);
        this.emit('axisChange', axis, this.pointerState.force, new THREE.Vector3());
    };
    handlePointerUp = (_e) => {
        this.pointerState.isDown = false;
        this.stateMachine.release();
        this.haptics.selection();
        this.emit('release', { x: 0, y: 0 }, 0, new THREE.Vector3());
    };
    handleTouchStart = (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        if (!touch)
            return;
        this.pointerState.isDown = true;
        this.pointerState.startPosition.set(touch.clientX, touch.clientY);
        this.pointerState.currentPosition.set(touch.clientX, touch.clientY);
        this.pointerState.delta.set(0, 0);
        this.pointerState.force = touch.force ?? 1;
        this.stateMachine.press(this.pointerState.startPosition);
        this.haptics.lightImpact();
        this.emit('press', { x: 0, y: 0 }, this.pointerState.force, new THREE.Vector3());
    };
    handleTouchMove = (e) => {
        e.preventDefault();
        if (!this.pointerState.isDown)
            return;
        const touch = e.touches[0];
        if (!touch)
            return;
        this.pointerState.currentPosition.set(touch.clientX, touch.clientY);
        this.pointerState.delta.subVectors(this.pointerState.currentPosition, this.pointerState.startPosition);
        this.pointerState.force = touch.force ?? 1;
        this.stateMachine.move(this.pointerState.currentPosition);
        const axis = this.normalizeAxis(this.pointerState.delta);
        this.emit('axisChange', axis, this.pointerState.force, new THREE.Vector3());
    };
    handleTouchEnd = (_e) => {
        this.pointerState.isDown = false;
        this.stateMachine.release();
        this.haptics.selection();
        this.emit('release', { x: 0, y: 0 }, 0, new THREE.Vector3());
    };
    handleGamepadConnected = (e) => {
        if (e.gamepad.index === this.config.gamepadIndex) {
            this.gamepadState.connected = true;
            this.haptics.success();
        }
    };
    handleGamepadDisconnected = (e) => {
        if (e.gamepad.index === this.config.gamepadIndex) {
            this.gamepadState.connected = false;
        }
    };
    startGamepadPolling() {
        const poll = () => {
            this.pollGamepad();
            this.animationFrameId = requestAnimationFrame(poll);
        };
        this.animationFrameId = requestAnimationFrame(poll);
    }
    stopGamepadPolling() {
        if (this.animationFrameId !== null) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
    }
    pollGamepad() {
        if (typeof navigator === 'undefined' || !navigator.getGamepads)
            return;
        const gamepads = navigator.getGamepads();
        const gamepad = gamepads[this.config.gamepadIndex];
        if (!gamepad) {
            this.gamepadState.connected = false;
            return;
        }
        this.gamepadState.connected = true;
        this.gamepadState.timestamp = gamepad.timestamp;
        const prevAxes = [...this.gamepadState.axes];
        this.gamepadState.axes = gamepad.axes.map((a) => this.applyDeadzone(a));
        this.gamepadState.buttons = gamepad.buttons.map((b) => b.pressed);
        const axisChanged = this.gamepadState.axes.some((a, i) => Math.abs(a - prevAxes[i]) > 0.01);
        if (axisChanged) {
            const axis = {
                x: this.gamepadState.axes[0] ?? 0,
                y: this.gamepadState.axes[1] ?? 0,
            };
            this.emit('axisChange', axis, 1, new THREE.Vector3());
        }
    }
    applyDeadzone(value) {
        const deadzone = this.config.deadzone;
        if (Math.abs(value) < deadzone)
            return 0;
        // Guard against division by zero when deadzone >= 1
        if (deadzone >= 1)
            return 0;
        const sign = Math.sign(value);
        return sign * ((Math.abs(value) - deadzone) / (1 - deadzone));
    }
    normalizeAxis(delta) {
        const length = delta.length();
        const normalizedLength = Math.min(length / this.config.maxDistance, 1);
        if (normalizedLength < this.config.deadzone) {
            return { x: 0, y: 0 };
        }
        const normalizedDelta = delta.clone().normalize().multiplyScalar(normalizedLength);
        return {
            x: Math.max(-1, Math.min(1, normalizedDelta.x)),
            y: Math.max(-1, Math.min(1, -normalizedDelta.y)),
        };
    }
    getAxis() {
        if (this.gamepadState.connected) {
            return {
                x: this.gamepadState.axes[0] ?? 0,
                y: this.gamepadState.axes[1] ?? 0,
            };
        }
        if (this.pointerState.isDown) {
            return this.normalizeAxis(this.pointerState.delta);
        }
        return { x: 0, y: 0 };
    }
    getForce() {
        return this.pointerState.force;
    }
    getDragState() {
        return this.stateMachine.getState();
    }
    isPressed() {
        const state = this.stateMachine.getState();
        return state === 'pressed' || state === 'dragging';
    }
    getHaptics() {
        return this.haptics;
    }
    getGamepadState() {
        return { ...this.gamepadState };
    }
}
export function createInputManager(config) {
    return new InputManager(config);
}
export function normalizeAxisValue(value, deadzone = 0.1) {
    if (Math.abs(value) < deadzone)
        return 0;
    // Guard against division by zero when deadzone >= 1
    if (deadzone >= 1)
        return 0;
    const sign = Math.sign(value);
    return sign * ((Math.abs(value) - deadzone) / (1 - deadzone));
}
export function clampAxis(axis) {
    const length = Math.sqrt(axis.x * axis.x + axis.y * axis.y);
    if (length <= 1)
        return axis;
    return {
        x: axis.x / length,
        y: axis.y / length,
    };
}
export function axisToAngle(axis) {
    return Math.atan2(axis.y, axis.x);
}
export function axisToMagnitude(axis) {
    return Math.min(1, Math.sqrt(axis.x * axis.x + axis.y * axis.y));
}
export function angleToAxis(angle, magnitude = 1) {
    return {
        x: Math.cos(angle) * magnitude,
        y: Math.sin(angle) * magnitude,
    };
}
//# sourceMappingURL=input.js.map