/**
 * Signed Distance Field (SDF) utilities
 *
 * SDFs represent geometry as a function that returns the distance to the nearest surface.
 * Negative values are inside, positive values are outside.
 *
 * These functions are designed to work both on CPU (for marching cubes)
 * and can be ported to GLSL for raymarching.
 *
 * Lifted from Otterfall procedural terrain system.
 */
import * as THREE from 'three';
/**
 * Sphere SDF
 * Optimized to avoid allocations for better performance in tight loops
 */
export declare function sdSphere(p: THREE.Vector3, center: THREE.Vector3, radius: number): number;
/**
 * Box SDF
 */
export declare function sdBox(p: THREE.Vector3, center: THREE.Vector3, halfExtents: THREE.Vector3): number;
/**
 * Infinite ground plane SDF (y = height)
 */
export declare function sdPlane(p: THREE.Vector3, height: number): number;
/**
 * Capsule/cylinder SDF
 * Optimized to avoid allocations for better performance in tight loops
 */
export declare function sdCapsule(p: THREE.Vector3, a: THREE.Vector3, b: THREE.Vector3, radius: number): number;
/**
 * Torus SDF
 * Optimized to avoid allocations for better performance in tight loops
 */
export declare function sdTorus(p: THREE.Vector3, center: THREE.Vector3, majorRadius: number, minorRadius: number): number;
/**
 * Cone SDF (tip at origin, pointing up)
 * Optimized to avoid allocations for better performance in tight loops
 */
export declare function sdCone(p: THREE.Vector3, center: THREE.Vector3, angle: number, height: number): number;
/**
 * Union (combine two shapes)
 */
export declare function opUnion(d1: number, d2: number): number;
/**
 * Subtraction (cut shape2 from shape1)
 */
export declare function opSubtraction(d1: number, d2: number): number;
/**
 * Intersection (keep only overlapping parts)
 */
export declare function opIntersection(d1: number, d2: number): number;
/**
 * Smooth union (blend two shapes together)
 */
export declare function opSmoothUnion(d1: number, d2: number, k: number): number;
/**
 * Smooth subtraction
 */
export declare function opSmoothSubtraction(d1: number, d2: number, k: number): number;
/**
 * Smooth intersection
 */
export declare function opSmoothIntersection(d1: number, d2: number, k: number): number;
/**
 * 3D Value noise
 *
 * @deprecated For new code, use createNoise3D from core/math module which provides
 * simplex noise with better performance and distribution
 */
export declare function noise3D(x: number, y: number, z: number): number;
/**
 * Fractal Brownian Motion (FBM) - layered noise
 *
 * @deprecated For new code, use fbm3D from core/math module which provides
 * simplex-based FBM with configurable frequency, persistence, and lacunarity
 */
export declare function fbm(x: number, y: number, z: number, octaves?: number): number;
/**
 * Domain warping for more organic shapes
 *
 * @deprecated For new code, use warpedNoise3D from core/math module
 */
export declare function warpedFbm(x: number, y: number, z: number, octaves?: number): number;
/**
 * Biome data for SDF terrain generation
 * Used in terrain height calculations and SDF operations
 */
export interface BiomeData {
    type: 'marsh' | 'forest' | 'desert' | 'tundra' | 'savanna' | 'mountain' | 'scrubland';
    center: THREE.Vector2;
    radius: number;
}
/**
 * Get the dominant biome at a position
 */
export declare function getBiomeAt(x: number, z: number, biomes: BiomeData[]): BiomeData;
/**
 * Terrain height function based on biome
 */
export declare function getTerrainHeight(x: number, z: number, biomes: BiomeData[]): number;
/**
 * Cave system SDF - creates tunnels and caverns
 */
export declare function sdCaves(x: number, y: number, z: number): number;
/**
 * Complete terrain SDF
 * Returns distance to terrain surface (negative = underground)
 */
export declare function sdTerrain(p: THREE.Vector3, biomes: BiomeData[]): number;
/**
 * Rock SDF with irregular shape
 * Optimized to avoid allocations for better performance in tight loops
 */
export declare function sdRock(p: THREE.Vector3, center: THREE.Vector3, baseRadius: number): number;
/**
 * Calculate the gradient (normal) of an SDF at a point
 * Uses tetrahedron method from marching.js for better accuracy
 * Optimized to minimize allocations
 */
export declare function calcNormal(p: THREE.Vector3, sdfFunc: (p: THREE.Vector3) => number, epsilon?: number): THREE.Vector3;
//# sourceMappingURL=sdf.d.ts.map