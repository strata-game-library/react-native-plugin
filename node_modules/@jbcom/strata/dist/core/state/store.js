/**
 * Zustand-based Game State Store Factory
 *
 * Creates a Zustand store with Immer for immutable updates, zundo for undo/redo,
 * and configurable persistence adapter for cross-platform storage.
 *
 * @module core/state/store
 * @public
 */
import { temporal } from 'zundo';
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { webPersistenceAdapter } from './adapters/web/persistence';
import { calculateChecksum } from './types';
const DEFAULT_CONFIG = {
    version: 1,
    storagePrefix: 'strata_state',
    maxUndoHistory: 50,
    enablePersistence: true,
    enableUndo: true,
};
/**
 * Creates a Zustand store with undo/redo and persistence capabilities.
 *
 * @public
 * @param initialState - The initial state value
 * @param config - Optional configuration
 * @returns A Zustand store with game state management features
 *
 * @example
 * ```typescript
 * interface PlayerState {
 *   health: number;
 *   position: [number, number, number];
 *   inventory: string[];
 * }
 *
 * const usePlayerStore = createGameStore<PlayerState>({
 *   health: 100,
 *   position: [0, 0, 0],
 *   inventory: [],
 * });
 *
 * // In a React component
 * const health = usePlayerStore(state => state.data.health);
 * const { set, undo, redo, save, load } = usePlayerStore();
 *
 * // Update state
 * set({ health: 50 });
 *
 * // Undo last change
 * undo();
 *
 * // Save to storage
 * await save('slot1');
 * ```
 */
export function createGameStore(initialState, config = {}) {
    const mergedConfig = { ...DEFAULT_CONFIG, ...config };
    const persistence = config.persistenceAdapter ?? webPersistenceAdapter;
    const checkpoints = new Map();
    const clonedInitial = JSON.parse(JSON.stringify(initialState));
    const baseStore = create()(temporal(immer((set, get, api) => ({
        data: JSON.parse(JSON.stringify(initialState)),
        _initial: clonedInitial,
        _version: mergedConfig.version,
        _lastSaved: null,
        _isDirty: false,
        set: (newState) => {
            set((state) => {
                const currentData = state.data;
                const value = typeof newState === 'function' ? newState(currentData) : newState;
                state.data = value;
                state._isDirty = true;
            });
        },
        patch: (partial) => {
            set((state) => {
                const currentData = state.data;
                const value = typeof partial === 'function' ? partial(currentData) : partial;
                Object.assign(state.data, value);
                state._isDirty = true;
            });
        },
        reset: () => {
            set((state) => {
                state.data = JSON.parse(JSON.stringify(clonedInitial));
                state._isDirty = false;
            });
        },
        undo: () => {
            const temporalStore = api.temporal;
            if (temporalStore) {
                temporalStore.getState().undo();
            }
        },
        redo: () => {
            const temporalStore = api.temporal;
            if (temporalStore) {
                temporalStore.getState().redo();
            }
        },
        canUndo: () => {
            const temporalStore = api.temporal;
            if (!temporalStore)
                return false;
            return temporalStore.getState().pastStates.length > 0;
        },
        canRedo: () => {
            const temporalStore = api.temporal;
            if (!temporalStore)
                return false;
            return temporalStore.getState().futureStates.length > 0;
        },
        clearHistory: () => {
            const temporalStore = api.temporal;
            if (temporalStore) {
                temporalStore.getState().clear();
            }
        },
        save: async (slot = 'default') => {
            if (!mergedConfig.enablePersistence)
                return false;
            const currentState = get();
            const saveData = {
                version: currentState._version,
                timestamp: Date.now(),
                state: structuredClone(currentState.data),
                checksum: calculateChecksum(currentState.data),
            };
            const key = `${mergedConfig.storagePrefix}_${slot}`;
            const success = await persistence.save(key, saveData);
            if (success) {
                set((state) => {
                    state._lastSaved = Date.now();
                    state._isDirty = false;
                });
            }
            mergedConfig.onSave?.(success);
            return success;
        },
        load: async (slot = 'default') => {
            if (!mergedConfig.enablePersistence)
                return false;
            const key = `${mergedConfig.storagePrefix}_${slot}`;
            const saveData = await persistence.load(key);
            if (saveData) {
                set((state) => {
                    state.data = saveData.state;
                    state._version = saveData.version;
                    state._lastSaved = saveData.timestamp;
                    state._isDirty = false;
                });
                mergedConfig.onLoad?.(saveData.state);
                return true;
            }
            mergedConfig.onLoad?.(null);
            return false;
        },
        deleteSave: async (slot) => {
            const key = `${mergedConfig.storagePrefix}_${slot}`;
            return persistence.delete(key);
        },
        listSaves: async () => {
            return persistence.listSaves(mergedConfig.storagePrefix);
        },
        createCheckpoint: async (name, options = {}) => {
            const currentState = get();
            const checkpoint = {
                name,
                description: options.description,
                state: JSON.parse(JSON.stringify(currentState.data)),
                timestamp: Date.now(),
                metadata: options.metadata,
            };
            checkpoints.set(name, checkpoint);
            if (options.persist !== false && mergedConfig.enablePersistence) {
                const key = `${mergedConfig.storagePrefix}_checkpoint_${name}`;
                const saveData = {
                    version: currentState._version,
                    timestamp: checkpoint.timestamp,
                    state: checkpoint.state,
                };
                return persistence.save(key, saveData);
            }
            return true;
        },
        restoreCheckpoint: async (name) => {
            const checkpoint = checkpoints.get(name);
            if (checkpoint) {
                set((state) => {
                    state.data = JSON.parse(JSON.stringify(checkpoint.state));
                    state._isDirty = true;
                });
                return true;
            }
            if (mergedConfig.enablePersistence) {
                const key = `${mergedConfig.storagePrefix}_checkpoint_${name}`;
                const saveData = await persistence.load(key);
                if (saveData) {
                    set((state) => {
                        state.data = saveData.state;
                        state._isDirty = true;
                    });
                    return true;
                }
            }
            return false;
        },
        deleteCheckpoint: async (name) => {
            checkpoints.delete(name);
            const key = `${mergedConfig.storagePrefix}_checkpoint_${name}`;
            return persistence.delete(key);
        },
        listCheckpoints: () => {
            return Array.from(checkpoints.values());
        },
        getData: () => get().data,
    })), { limit: mergedConfig.maxUndoHistory }));
    const store = baseStore;
    return store;
}
/**
 * Creates a persistence adapter from a custom implementation.
 *
 * @public
 * @param adapter - Custom adapter implementing PersistenceAdapter interface
 * @returns The validated adapter
 *
 * @example
 * ```typescript
 * const customAdapter = createPersistenceAdapter({
 *   save: async (key, data) => { ... },
 *   load: async (key) => { ... },
 *   delete: async (key) => { ... },
 *   listSaves: async (prefix) => { ... },
 *   getSaveInfo: async (key) => { ... },
 * });
 * ```
 */
export function createPersistenceAdapter(adapter) {
    const requiredMethods = ['save', 'load', 'delete', 'listSaves', 'getSaveInfo'];
    for (const method of requiredMethods) {
        if (typeof adapter[method] !== 'function') {
            throw new Error(`PersistenceAdapter missing required method: ${method}`);
        }
    }
    return adapter;
}
//# sourceMappingURL=store.js.map