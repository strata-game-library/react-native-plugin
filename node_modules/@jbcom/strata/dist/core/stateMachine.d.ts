import * as THREE from 'three';
export interface StateCallbacks<T = any> {
    onEnter?: (context: T) => void;
    onUpdate?: (context: T, deltaTime: number) => void;
    onExit?: (context: T) => void;
}
export interface State<T = any> {
    name: string;
    callbacks: StateCallbacks<T>;
}
export interface TransitionCondition<T = any> {
    from: string;
    to: string;
    condition: (context: T) => boolean;
    priority?: number;
}
export interface StateHistoryEntry {
    stateName: string;
    timestamp: number;
    duration: number;
}
export interface StateMachineConfig<T = any> {
    initialState: string;
    states: State<T>[];
    transitions: TransitionCondition<T>[];
    maxHistoryLength?: number;
}
export declare class StateMachine<T = any> {
    private states;
    private transitions;
    private currentState;
    private previousState;
    private stateStartTime;
    private history;
    private maxHistoryLength;
    private isPaused;
    private context;
    constructor(config: StateMachineConfig<T>, context: T);
    getCurrentState(): string | null;
    getPreviousState(): string | null;
    getStateTime(): number;
    getHistory(): StateHistoryEntry[];
    getContext(): T;
    setContext(context: T): void;
    updateContext(updates: Partial<T>): void;
    pause(): void;
    resume(): void;
    isPausedState(): boolean;
    update(deltaTime: number): void;
    transitionTo(stateName: string): boolean;
    forceTransition(stateName: string): boolean;
    addState(state: State<T>): void;
    removeState(stateName: string): boolean;
    addTransition(transition: TransitionCondition<T>): void;
    removeTransition(from: string, to: string): boolean;
    hasState(stateName: string): boolean;
    getAvailableTransitions(): string[];
    private addToHistory;
    clearHistory(): void;
    reset(): void;
    serialize(): object;
}
export interface AIContext {
    position: THREE.Vector3;
    rotation: THREE.Euler;
    velocity: THREE.Vector3;
    target: THREE.Vector3 | null;
    threat: THREE.Vector3 | null;
    waypoints: THREE.Vector3[];
    currentWaypointIndex: number;
    speed: number;
    maxSpeed: number;
    detectionRadius: number;
    fleeRadius: number;
    health: number;
    stamina: number;
    isAlerted: boolean;
    lastSeenTarget: THREE.Vector3 | null;
    lastSeenTime: number;
    homePosition: THREE.Vector3;
    wanderAngle: number;
    lookDirection: THREE.Vector3;
    idleTimer: number;
    patrolPauseTimer: number;
}
export declare function createDefaultAIContext(position?: THREE.Vector3): AIContext;
export declare function createStateMachine<T>(config: StateMachineConfig<T>, context: T): StateMachine<T>;
export declare function createState<T>(name: string, callbacks: StateCallbacks<T>): State<T>;
export declare function createTransition<T>(from: string, to: string, condition: (context: T) => boolean, priority?: number): TransitionCondition<T>;
//# sourceMappingURL=stateMachine.d.ts.map