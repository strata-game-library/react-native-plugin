/**
 * God Rays Core - Pure TypeScript (no React)
 *
 * Core algorithms for volumetric light shafts and god rays
 * Implements radial blur, sun occlusion, and scattering calculations
 */
import * as THREE from 'three';
export interface GodRaysMaterialOptions {
    lightPosition?: THREE.Vector3;
    lightColor?: THREE.Color;
    intensity?: number;
    decay?: number;
    density?: number;
    weight?: number;
    exposure?: number;
    samples?: number;
    scattering?: number;
    noiseFactor?: number;
}
export interface VolumetricSpotlightMaterialOptions {
    lightPosition?: THREE.Vector3;
    lightDirection?: THREE.Vector3;
    lightColor?: THREE.Color;
    intensity?: number;
    angle?: number;
    penumbra?: number;
    distance?: number;
    dustDensity?: number;
}
export interface VolumetricPointLightMaterialOptions {
    lightPosition?: THREE.Vector3;
    lightColor?: THREE.Color;
    intensity?: number;
    radius?: number;
    dustDensity?: number;
    flicker?: number;
}
export interface RadialBlurOptions {
    center: THREE.Vector2;
    samples: number;
    decay: number;
    density: number;
    weight: number;
}
export interface OcclusionResult {
    occluded: boolean;
    occlusionFactor: number;
    visibleFraction: number;
}
export interface ScatteringParams {
    angle: number;
    intensity: number;
    color: THREE.Color;
}
export declare function calculateRadialBlur(uv: THREE.Vector2, center: THREE.Vector2, options: RadialBlurOptions): {
    intensity: number;
    direction: THREE.Vector2;
};
/**
 * Calculate sun occlusion by raycasting against occluders
 *
 * @warning This function performs multiple raycasts (default 16) per call.
 * Avoid calling every frame - consider throttling or caching results.
 *
 * @param sunPosition World position of the sun
 * @param camera The camera to raycast from
 * @param occluders Objects that can occlude the sun
 * @param sampleCount Number of sample rays (default 16)
 * @returns Occlusion result with visibility information
 */
export declare function calculateSunOcclusion(sunPosition: THREE.Vector3, camera: THREE.Camera, occluders: THREE.Object3D[], sampleCount?: number): OcclusionResult;
export declare function calculateScatteringIntensity(viewDirection: THREE.Vector3, lightDirection: THREE.Vector3, params?: Partial<ScatteringParams>): number;
/**
 * Get the screen-space position of a light source
 * @param lightWorldPosition World position of the light
 * @param camera The camera for projection
 * @returns Screen position in normalized coordinates (0-1) or null if behind camera
 */
export declare function getLightScreenPosition(lightWorldPosition: THREE.Vector3, camera: THREE.Camera): THREE.Vector2 | null;
export declare function calculateGodRayIntensityFromAngle(sunAltitude: number, maxIntensity?: number): number;
export declare function createGodRaysMaterial(options?: GodRaysMaterialOptions): THREE.ShaderMaterial;
export declare function createVolumetricSpotlightMaterial(options?: VolumetricSpotlightMaterialOptions): THREE.ShaderMaterial;
export declare function createVolumetricPointLightMaterial(options?: VolumetricPointLightMaterialOptions): THREE.ShaderMaterial;
export declare function createSpotlightConeGeometry(angle: number, distance: number, segments?: number): THREE.ConeGeometry;
export declare function createPointLightSphereGeometry(radius: number, segments?: number): THREE.SphereGeometry;
export declare function updateGodRaysLightPosition(material: THREE.ShaderMaterial, lightPosition: THREE.Vector3, camera: THREE.Camera): boolean;
/**
 * Blend god ray colors based on sun altitude
 * @param baseColor Base god ray color
 * @param atmosphereColor Atmosphere tint color
 * @param sunAltitude Sun altitude in degrees
 * @param target Optional target color to avoid allocations in render loops
 * @returns Blended color
 */
export declare function blendGodRayColors(baseColor: THREE.Color, atmosphereColor: THREE.Color, sunAltitude: number, target?: THREE.Color): THREE.Color;
//# sourceMappingURL=godRays.d.ts.map