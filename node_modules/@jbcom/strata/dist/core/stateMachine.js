import * as THREE from 'three';
export class StateMachine {
    states = new Map();
    transitions = [];
    currentState = null;
    previousState = null;
    stateStartTime = 0;
    history = [];
    maxHistoryLength;
    isPaused = false;
    context;
    constructor(config, context) {
        this.context = context;
        this.maxHistoryLength = config.maxHistoryLength ?? 50;
        for (const state of config.states) {
            this.states.set(state.name, state);
        }
        this.transitions = [...config.transitions].sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
        const initialState = this.states.get(config.initialState);
        if (initialState) {
            this.transitionTo(config.initialState);
        }
    }
    getCurrentState() {
        return this.currentState?.name ?? null;
    }
    getPreviousState() {
        return this.previousState?.name ?? null;
    }
    getStateTime() {
        return Date.now() - this.stateStartTime;
    }
    getHistory() {
        return [...this.history];
    }
    getContext() {
        return this.context;
    }
    setContext(context) {
        this.context = context;
    }
    updateContext(updates) {
        this.context = { ...this.context, ...updates };
    }
    pause() {
        this.isPaused = true;
    }
    resume() {
        this.isPaused = false;
    }
    isPausedState() {
        return this.isPaused;
    }
    update(deltaTime) {
        if (this.isPaused || !this.currentState)
            return;
        for (const transition of this.transitions) {
            if (transition.from === this.currentState.name && transition.condition(this.context)) {
                this.transitionTo(transition.to);
                break;
            }
        }
        this.currentState.callbacks.onUpdate?.(this.context, deltaTime);
    }
    transitionTo(stateName) {
        const newState = this.states.get(stateName);
        if (!newState) {
            console.warn(`StateMachine: State "${stateName}" not found`);
            return false;
        }
        if (this.currentState) {
            const duration = Date.now() - this.stateStartTime;
            this.addToHistory(this.currentState.name, this.stateStartTime, duration);
            this.currentState.callbacks.onExit?.(this.context);
            this.previousState = this.currentState;
        }
        this.currentState = newState;
        this.stateStartTime = Date.now();
        this.currentState.callbacks.onEnter?.(this.context);
        return true;
    }
    forceTransition(stateName) {
        return this.transitionTo(stateName);
    }
    addState(state) {
        this.states.set(state.name, state);
    }
    removeState(stateName) {
        if (this.currentState?.name === stateName) {
            return false;
        }
        return this.states.delete(stateName);
    }
    addTransition(transition) {
        this.transitions.push(transition);
        this.transitions.sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
    }
    removeTransition(from, to) {
        const index = this.transitions.findIndex((t) => t.from === from && t.to === to);
        if (index !== -1) {
            this.transitions.splice(index, 1);
            return true;
        }
        return false;
    }
    hasState(stateName) {
        return this.states.has(stateName);
    }
    getAvailableTransitions() {
        if (!this.currentState)
            return [];
        return this.transitions.filter((t) => t.from === this.currentState?.name).map((t) => t.to);
    }
    addToHistory(stateName, timestamp, duration) {
        this.history.push({ stateName, timestamp, duration });
        if (this.history.length > this.maxHistoryLength) {
            this.history.shift();
        }
    }
    clearHistory() {
        this.history = [];
    }
    reset() {
        if (this.currentState) {
            this.currentState.callbacks.onExit?.(this.context);
        }
        this.currentState = null;
        this.previousState = null;
        this.stateStartTime = 0;
        this.clearHistory();
        this.isPaused = false;
    }
    serialize() {
        return {
            currentState: this.currentState?.name ?? null,
            previousState: this.previousState?.name ?? null,
            stateStartTime: this.stateStartTime,
            history: this.history,
            isPaused: this.isPaused,
        };
    }
}
export function createDefaultAIContext(position = new THREE.Vector3()) {
    return {
        position: position.clone(),
        rotation: new THREE.Euler(),
        velocity: new THREE.Vector3(),
        target: null,
        threat: null,
        waypoints: [],
        currentWaypointIndex: 0,
        speed: 0,
        maxSpeed: 5,
        detectionRadius: 10,
        fleeRadius: 15,
        health: 100,
        stamina: 100,
        isAlerted: false,
        lastSeenTarget: null,
        lastSeenTime: 0,
        homePosition: position.clone(),
        wanderAngle: 0,
        lookDirection: new THREE.Vector3(0, 0, 1),
        idleTimer: 0,
        patrolPauseTimer: 0,
    };
}
export function createStateMachine(config, context) {
    return new StateMachine(config, context);
}
export function createState(name, callbacks) {
    return { name, callbacks };
}
export function createTransition(from, to, condition, priority = 0) {
    return { from, to, condition, priority };
}
//# sourceMappingURL=stateMachine.js.map