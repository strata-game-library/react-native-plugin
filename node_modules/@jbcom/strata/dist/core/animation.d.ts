/**
 * Core animation algorithms
 *
 * Pure TypeScript animation utilities including IK solvers, spring dynamics,
 * and procedural locomotion for skeletal and object-based animation.
 * @module core/animation
 */
import * as THREE from 'three';
export interface BoneChain {
    bones: THREE.Object3D[];
    lengths: number[];
    totalLength: number;
    constraints?: BoneConstraint[];
}
export interface BoneConstraint {
    boneIndex: number;
    minAngle?: number;
    maxAngle?: number;
    axis?: THREE.Vector3;
    limitType?: 'hinge' | 'ball' | 'twist';
    twistMin?: number;
    twistMax?: number;
    swingLimit?: number;
}
export interface IKSolverResult {
    positions: THREE.Vector3[];
    rotations: THREE.Quaternion[];
    reached: boolean;
    iterations: number;
    error: number;
}
export interface SpringConfig {
    stiffness: number;
    damping: number;
    mass: number;
    restLength?: number;
}
export interface SpringState {
    position: THREE.Vector3;
    velocity: THREE.Vector3;
}
export interface GaitConfig {
    stepLength: number;
    stepHeight: number;
    stepDuration: number;
    bodyBob: number;
    bodySwayAmplitude: number;
    hipRotation: number;
    phaseOffset: number;
    footOvershoot: number;
}
export interface GaitState {
    phase: number;
    leftFootTarget: THREE.Vector3;
    rightFootTarget: THREE.Vector3;
    leftFootLifted: boolean;
    rightFootLifted: boolean;
    bodyOffset: THREE.Vector3;
    bodyRotation: THREE.Euler;
}
export interface LookAtConfig {
    maxAngle: number;
    speed: number;
    deadzone: number;
    smoothing: number;
    upVector?: THREE.Vector3;
    forwardVector?: THREE.Vector3;
}
export interface LookAtState {
    currentRotation: THREE.Quaternion;
    targetRotation: THREE.Quaternion;
    velocity: THREE.Vector3;
}
export declare function createBoneChain(bones: THREE.Object3D[]): BoneChain;
export declare function createBoneChainFromLengths(root: THREE.Object3D, boneLengths: number[], direction?: THREE.Vector3): BoneChain;
export declare class FABRIKSolver {
    private tolerance;
    private maxIterations;
    constructor(tolerance?: number, maxIterations?: number);
    solve(chain: BoneChain, target: THREE.Vector3, pole?: THREE.Vector3): IKSolverResult;
    private backward;
    private forward;
    private applyPoleConstraint;
    private applyConstraints;
    private calculateRotations;
    apply(chain: BoneChain, result: IKSolverResult): void;
}
export declare class CCDSolver {
    private tolerance;
    private maxIterations;
    private dampingFactor;
    constructor(tolerance?: number, maxIterations?: number, dampingFactor?: number);
    solve(chain: BoneChain, target: THREE.Vector3): IKSolverResult;
    private updatePositions;
    apply(chain: BoneChain, result: IKSolverResult): void;
}
export declare class TwoBoneIKSolver {
    solve(rootPos: THREE.Vector3, _midPos: THREE.Vector3, _endPos: THREE.Vector3, target: THREE.Vector3, poleTarget: THREE.Vector3, upperLength: number, lowerLength: number): {
        midPosition: THREE.Vector3;
        endPosition: THREE.Vector3;
        upperRotation: THREE.Quaternion;
        lowerRotation: THREE.Quaternion;
    };
    solveLimb(root: THREE.Object3D, mid: THREE.Object3D, end: THREE.Object3D, target: THREE.Vector3, poleTarget: THREE.Vector3): void;
}
export declare class LookAtController {
    private config;
    private currentQuat;
    private velocity;
    constructor(config?: Partial<LookAtConfig>);
    update(object: THREE.Object3D, target: THREE.Vector3, deltaTime: number): THREE.Quaternion;
    apply(object: THREE.Object3D): void;
    reset(): void;
}
export declare class SpringDynamics {
    private config;
    private position;
    private velocity;
    private restPosition;
    constructor(config?: Partial<SpringConfig>, initialPosition?: THREE.Vector3);
    update(targetPosition: THREE.Vector3, deltaTime: number): THREE.Vector3;
    getPosition(): THREE.Vector3;
    getVelocity(): THREE.Vector3;
    setPosition(position: THREE.Vector3): void;
    setVelocity(velocity: THREE.Vector3): void;
    reset(position?: THREE.Vector3): void;
}
export declare class SpringChain {
    private springs;
    private restLengths;
    constructor(nodeCount: number, config?: Partial<SpringConfig>, restLength?: number);
    update(rootPosition: THREE.Vector3, rootRotation: THREE.Quaternion, deltaTime: number, gravity?: THREE.Vector3): THREE.Vector3[];
    reset(positions: THREE.Vector3[]): void;
    getPositions(): THREE.Vector3[];
}
export declare class ProceduralGait {
    private config;
    private phase;
    private leftFootGrounded;
    private rightFootGrounded;
    private lastBodyPosition;
    constructor(config?: Partial<GaitConfig>);
    update(bodyPosition: THREE.Vector3, bodyForward: THREE.Vector3, velocity: THREE.Vector3, deltaTime: number): GaitState;
    private calculateFootTarget;
    reset(): void;
    getPhase(): number;
    setPhase(phase: number): void;
}
export declare function clampAngle(angle: number, min: number, max: number): number;
export declare function dampedSpring(current: number, target: number, velocity: {
    value: number;
}, stiffness: number, damping: number, deltaTime: number): number;
export declare function dampedSpringVector3(current: THREE.Vector3, target: THREE.Vector3, velocity: THREE.Vector3, stiffness: number, damping: number, deltaTime: number, out?: THREE.Vector3): THREE.Vector3;
export declare function hermiteInterpolate(p0: THREE.Vector3, p1: THREE.Vector3, m0: THREE.Vector3, m1: THREE.Vector3, t: number): THREE.Vector3;
export declare function sampleCurve(points: THREE.Vector3[], t: number, tension?: number): THREE.Vector3;
export declare function calculateBoneRotation(boneStart: THREE.Vector3, boneEnd: THREE.Vector3, upVector?: THREE.Vector3): THREE.Quaternion;
//# sourceMappingURL=animation.d.ts.map