/**
 * Core Physics Utilities
 *
 * Pure TypeScript physics helper functions and type definitions
 * for use with @react-three/rapier.
 * @module core/physics
 */
import * as THREE from 'three';
/**
 * Core physics configuration options
 */
export interface PhysicsConfig {
    gravity: [number, number, number];
    timeStep: number;
    maxStabilizationIterations: number;
    maxVelocityIterations: number;
    maxVelocityFrictionIterations: number;
    erp: number;
    allowedLinearError: number;
    predictionDistance: number;
}
/**
 * Collision layer bitmask definitions
 */
export declare enum CollisionLayer {
    Default = 1,
    Static = 2,
    Dynamic = 4,
    Character = 8,
    Vehicle = 16,
    Projectile = 32,
    Trigger = 64,
    Debris = 128,
    Water = 256,
    All = 65535
}
/**
 * Collision filter presets
 */
export interface CollisionFilter {
    memberships: number;
    filter: number;
}
export declare const collisionFilters: Record<string, CollisionFilter>;
/**
 * Character controller configuration
 */
export interface CharacterControllerConfig {
    capsuleRadius: number;
    capsuleHeight: number;
    mass: number;
    maxSpeed: number;
    acceleration: number;
    deceleration: number;
    jumpForce: number;
    maxJumps: number;
    groundCheckDistance: number;
    slopeLimit: number;
    stepHeight: number;
    coyoteTime: number;
    jumpBufferTime: number;
    airControl: number;
    gravityScale: number;
    snapToGroundDistance: number;
    skinWidth: number;
    autoStepEnabled: boolean;
    slideEnabled: boolean;
}
/**
 * Vehicle physics configuration
 */
export interface VehicleConfig {
    chassisMass: number;
    chassisSize: [number, number, number];
    wheelRadius: number;
    wheelWidth: number;
    wheelPositions: [number, number, number][];
    suspensionRestLength: number;
    suspensionStiffness: number;
    suspensionDamping: number;
    suspensionTravel: number;
    maxSteerAngle: number;
    driveWheels: 'front' | 'rear' | 'all';
    motorForce: number;
    brakeForce: number;
    frictionSlip: number;
    rollInfluence: number;
    antiRoll: number;
    centerOfMassOffset: [number, number, number];
}
/**
 * Wheel configuration for vehicles
 */
export interface WheelConfig {
    position: [number, number, number];
    radius: number;
    suspensionRestLength: number;
    suspensionStiffness: number;
    suspensionDamping: number;
    maxSuspensionForce: number;
    frictionSlip: number;
    isSteering: boolean;
    isDriving: boolean;
    isBraking: boolean;
}
/**
 * Ragdoll joint configuration
 */
export interface RagdollJointConfig {
    parent: string;
    child: string;
    type: 'spherical' | 'revolute' | 'prismatic' | 'fixed';
    anchor1: [number, number, number];
    anchor2: [number, number, number];
    axis?: [number, number, number];
    limits?: {
        min: number;
        max: number;
    };
    twistLimits?: {
        min: number;
        max: number;
    };
}
/**
 * Ragdoll body part configuration
 */
export interface RagdollBodyPart {
    name: string;
    type: 'capsule' | 'box' | 'sphere';
    size: [number, number, number] | [number, number] | [number];
    position: [number, number, number];
    rotation?: [number, number, number];
    mass: number;
}
/**
 * Complete ragdoll configuration
 */
export interface RagdollConfig {
    bodyParts: RagdollBodyPart[];
    joints: RagdollJointConfig[];
    linearDamping: number;
    angularDamping: number;
    enableSelfCollision: boolean;
    sleepThreshold: number;
}
/**
 * Physics material properties
 */
export interface PhysicsMaterial {
    friction: number;
    restitution: number;
    frictionCombine?: 'average' | 'min' | 'max' | 'multiply';
    restitutionCombine?: 'average' | 'min' | 'max' | 'multiply';
    density?: number;
}
/**
 * Destructible object configuration
 */
export interface DestructibleConfig {
    health: number;
    breakForce: number;
    shardCount: number;
    shardScale: [number, number, number];
    explosionForce: number;
    explosionRadius: number;
    shardLifetime: number;
    shardMass: number;
    shardAngularVelocity: [number, number, number];
}
/**
 * Buoyancy configuration for floating objects
 */
export interface BuoyancyConfig {
    waterLevel: number;
    buoyancyForce: number;
    waterDrag: number;
    waterAngularDrag: number;
    voxelResolution: number;
    samplePointCount: number;
    dynamicWater: boolean;
}
/**
 * Calculate an impulse to apply based on desired velocity change
 * @param currentVelocity - Current velocity vector
 * @param targetVelocity - Target velocity vector
 * @param mass - Object mass
 * @returns Impulse vector to apply
 */
export declare function calculateImpulse(currentVelocity: THREE.Vector3, targetVelocity: THREE.Vector3, mass: number): THREE.Vector3;
/**
 * Calculate continuous force to achieve target velocity
 * @param currentVelocity - Current velocity
 * @param targetVelocity - Target velocity
 * @param mass - Object mass
 * @param deltaTime - Time step
 * @returns Force vector to apply
 */
export declare function calculateForce(currentVelocity: THREE.Vector3, targetVelocity: THREE.Vector3, mass: number, deltaTime: number): THREE.Vector3;
/**
 * Calculate jump impulse for character controllers
 * @param jumpHeight - Desired jump height
 * @param gravity - Gravity magnitude
 * @param mass - Character mass
 * @returns Upward impulse magnitude
 */
export declare function calculateJumpImpulse(jumpHeight: number, gravity: number, mass: number): number;
/**
 * Calculate landing velocity from fall height
 * @param fallHeight - Height of the fall
 * @param gravity - Gravity magnitude
 * @returns Landing velocity magnitude
 */
export declare function calculateLandingVelocity(fallHeight: number, gravity: number): number;
/**
 * Apply drag force to velocity
 * @param velocity - Current velocity
 * @param dragCoefficient - Drag coefficient
 * @param deltaTime - Time step
 * @returns New velocity after drag
 */
export declare function applyDrag(velocity: THREE.Vector3, dragCoefficient: number, deltaTime: number): THREE.Vector3;
/**
 * Calculate buoyancy force for a submerged point
 * @param depth - Depth below water surface (positive = submerged)
 * @param buoyancyStrength - Strength multiplier
 * @param mass - Object mass
 * @returns Upward buoyancy force magnitude
 */
export declare function calculateBuoyancyForce(depth: number, buoyancyStrength: number, mass: number): number;
/**
 * Calculate slope angle from surface normal
 * @param normal - Surface normal vector
 * @returns Slope angle in radians
 */
export declare function calculateSlopeAngle(normal: THREE.Vector3): number;
/**
 * Check if slope is walkable
 * @param normal - Surface normal vector
 * @param maxSlopeAngle - Maximum walkable slope angle in radians
 * @returns Whether the slope can be walked on
 */
export declare function isWalkableSlope(normal: THREE.Vector3, maxSlopeAngle: number): boolean;
/**
 * Project velocity onto ground plane
 * @param velocity - Input velocity
 * @param groundNormal - Ground surface normal
 * @returns Velocity projected onto ground plane
 */
export declare function projectVelocityOntoGround(velocity: THREE.Vector3, groundNormal: THREE.Vector3): THREE.Vector3;
/**
 * Calculate steering force for vehicle physics
 * @param currentDirection - Current forward direction
 * @param targetDirection - Target direction
 * @param maxSteerAngle - Maximum steering angle
 * @returns Steering angle to apply
 */
export declare function calculateSteeringAngle(currentDirection: THREE.Vector3, targetDirection: THREE.Vector3, maxSteerAngle: number): number;
/**
 * Calculate suspension force using spring-damper model
 * @param compression - Current suspension compression (0-1)
 * @param velocity - Vertical velocity
 * @param stiffness - Spring stiffness
 * @param damping - Damping coefficient
 * @returns Suspension force magnitude
 */
export declare function calculateSuspensionForce(compression: number, velocity: number, stiffness: number, damping: number): number;
/**
 * Calculate explosion impulse falloff
 * @param distance - Distance from explosion center
 * @param explosionRadius - Explosion radius
 * @param maxForce - Maximum force at center
 * @returns Force at given distance
 */
export declare function calculateExplosionForce(distance: number, explosionRadius: number, maxForce: number): number;
/**
 * Generate random debris velocity for destructible objects
 * @param explosionCenter - Center of explosion
 * @param debrisPosition - Position of debris piece
 * @param baseForce - Base explosion force
 * @param randomness - Randomness factor (0-1)
 * @returns Velocity vector for debris
 */
export declare function generateDebrisVelocity(explosionCenter: THREE.Vector3, debrisPosition: THREE.Vector3, baseForce: number, randomness?: number): THREE.Vector3;
/**
 * Create default physics configuration
 * @returns Default physics config
 */
export declare function createDefaultPhysicsConfig(): PhysicsConfig;
/**
 * Create default character controller configuration
 * @returns Default character controller config
 */
export declare function createDefaultCharacterConfig(): CharacterControllerConfig;
/**
 * Create default vehicle configuration
 * @returns Default vehicle config
 */
export declare function createDefaultVehicleConfig(): VehicleConfig;
/**
 * Create a humanoid ragdoll configuration
 * @param scale - Scale factor for the ragdoll
 * @returns Ragdoll configuration
 */
export declare function createHumanoidRagdoll(scale?: number): RagdollConfig;
/**
 * Create default destructible configuration
 * @returns Default destructible config
 */
export declare function createDefaultDestructibleConfig(): DestructibleConfig;
/**
 * Create default buoyancy configuration
 * @returns Default buoyancy config
 */
export declare function createDefaultBuoyancyConfig(): BuoyancyConfig;
//# sourceMappingURL=physics.d.ts.map