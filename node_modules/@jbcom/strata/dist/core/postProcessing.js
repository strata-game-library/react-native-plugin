/**
 * Post-Processing Core Utilities
 *
 * Provides types, interfaces, and helper functions for post-processing effects.
 * Designed to work with @react-three/postprocessing.
 */
import * as THREE from 'three';
/**
 * Pre-defined LUT configurations
 */
export const lutConfigs = {
    neutral: { intensity: 0 },
    warm: { intensity: 0.5 },
    cool: { intensity: 0.5 },
    cinematic: { intensity: 0.8 },
    vintage: { intensity: 0.7 },
};
/**
 * Calculate focus distance from camera to a target object
 * @param camera The camera
 * @param targetPosition Target position in world space
 * @returns Distance from camera to target
 */
export function calculateFocusDistance(camera, targetPosition) {
    const cameraWorldPos = new THREE.Vector3();
    camera.getWorldPosition(cameraWorldPos);
    return cameraWorldPos.distanceTo(targetPosition);
}
/**
 * Calculate focus distance to center of a mesh
 * @param camera The camera
 * @param mesh Target mesh
 * @returns Distance from camera to mesh center
 */
export function calculateFocusDistanceToMesh(camera, mesh) {
    const meshWorldPos = new THREE.Vector3();
    mesh.getWorldPosition(meshWorldPos);
    return calculateFocusDistance(camera, meshWorldPos);
}
/**
 * Convert focal length (mm) to field of view (radians)
 * @param focalLength Focal length in mm
 * @param sensorHeight Sensor height in mm (default 24 for full frame)
 * @returns Field of view in radians
 */
export function focalLengthToFOV(focalLength, sensorHeight = 24) {
    return 2 * Math.atan(sensorHeight / (2 * focalLength));
}
/**
 * Convert field of view (radians) to focal length (mm)
 * @param fov Field of view in radians
 * @param sensorHeight Sensor height in mm (default 24 for full frame)
 * @returns Focal length in mm
 */
export function fovToFocalLength(fov, sensorHeight = 24) {
    return sensorHeight / (2 * Math.tan(fov / 2));
}
/**
 * Calculate bokeh scale based on aperture (f-stop)
 * @param fStop Aperture f-stop value (e.g., 1.4, 2.8, 5.6). Must be positive.
 * @returns Bokeh scale value
 * @throws Error if fStop is not positive
 */
export function apertureToBokehScale(fStop) {
    if (fStop <= 0) {
        throw new Error('apertureToBokehScale: fStop must be a positive number');
    }
    return Math.max(0.5, 8 / fStop);
}
/**
 * Get DOF settings for common photography scenarios
 */
export const dofScenarios = {
    /** Portrait: shallow DOF, f/1.4 equivalent */
    portrait: {
        focusDistance: 2,
        focalLength: 85,
        bokehScale: 5,
    },
    /** Landscape: deep DOF, f/11 equivalent */
    landscape: {
        focusDistance: 50,
        focalLength: 24,
        bokehScale: 0.7,
    },
    /** Macro: very shallow DOF */
    macro: {
        focusDistance: 0.3,
        focalLength: 100,
        bokehScale: 8,
    },
    /** Street: moderate DOF, f/4 equivalent */
    street: {
        focusDistance: 5,
        focalLength: 35,
        bokehScale: 2,
    },
    /** Cinematic: film-like DOF */
    cinematic: {
        focusDistance: 4,
        focalLength: 50,
        bokehScale: 3,
    },
};
/**
 * Default settings for each effect type
 */
export const defaultEffectSettings = {
    bloom: {
        intensity: 1,
        luminanceThreshold: 0.9,
        luminanceSmoothing: 0.025,
        mipmapBlur: true,
        radius: 0.85,
        levels: 8,
    },
    dof: {
        focusDistance: 5,
        focalLength: 50,
        bokehScale: 2,
        resolution: 512,
        pentagon: true,
    },
    vignette: {
        darkness: 0.5,
        offset: 0.5,
        technique: 'default',
    },
    chromaticAberration: {
        offset: { x: 0.002, y: 0.002 },
        radialModulation: true,
        modulationOffset: 0.15,
    },
    filmGrain: {
        intensity: 0.1,
        luminance: 0.8,
    },
    colorGrading: {
        hue: 0,
        saturation: 0,
        brightness: 0,
    },
    ssao: {
        samples: 9,
        radius: 0.1,
        intensity: 1,
        luminanceInfluence: 0.7,
        bias: 0.5,
    },
    toneMapping: {
        mode: 1,
        exposure: 1,
        whitePoint: 4,
    },
    noise: {
        premultiply: false,
    },
    brightnessContrast: {
        brightness: 0,
        contrast: 0,
    },
    sepia: {
        intensity: 1,
    },
};
/**
 * Blend two preset configurations
 * @param presetA First preset
 * @param presetB Second preset
 * @param t Blend factor (0 = presetA, 1 = presetB)
 * @returns Blended preset
 */
export function blendPostProcessingPresets(presetA, presetB, t) {
    const clampedT = Math.max(0, Math.min(1, t));
    const blend = (a, b, def) => {
        const va = a ?? def;
        const vb = b ?? def;
        return va + (vb - va) * clampedT;
    };
    return {
        name: `${presetA.name} â†’ ${presetB.name}`,
        description: `Blend between ${presetA.name} and ${presetB.name}`,
        mood: clampedT < 0.5 ? presetA.mood : presetB.mood,
        bloom: presetA.bloom || presetB.bloom
            ? {
                intensity: blend(presetA.bloom?.intensity, presetB.bloom?.intensity, 1),
                luminanceThreshold: blend(presetA.bloom?.luminanceThreshold, presetB.bloom?.luminanceThreshold, 0.9),
                luminanceSmoothing: blend(presetA.bloom?.luminanceSmoothing, presetB.bloom?.luminanceSmoothing, 0.025),
                radius: blend(presetA.bloom?.radius, presetB.bloom?.radius, 0.85),
            }
            : undefined,
        dof: presetA.dof || presetB.dof
            ? {
                focusDistance: blend(presetA.dof?.focusDistance, presetB.dof?.focusDistance, 5),
                focalLength: blend(presetA.dof?.focalLength, presetB.dof?.focalLength, 50),
                bokehScale: blend(presetA.dof?.bokehScale, presetB.dof?.bokehScale, 2),
            }
            : undefined,
        vignette: presetA.vignette || presetB.vignette
            ? {
                darkness: blend(presetA.vignette?.darkness, presetB.vignette?.darkness, 0.5),
                offset: blend(presetA.vignette?.offset, presetB.vignette?.offset, 0.5),
            }
            : undefined,
        filmGrain: presetA.filmGrain || presetB.filmGrain
            ? {
                intensity: blend(presetA.filmGrain?.intensity, presetB.filmGrain?.intensity, 0.1),
            }
            : undefined,
        colorGrading: presetA.colorGrading || presetB.colorGrading
            ? {
                hue: blend(presetA.colorGrading?.hue, presetB.colorGrading?.hue, 0),
                saturation: blend(presetA.colorGrading?.saturation, presetB.colorGrading?.saturation, 0),
                brightness: blend(presetA.colorGrading?.brightness, presetB.colorGrading?.brightness, 0),
            }
            : undefined,
        chromaticAberration: presetA.chromaticAberration || presetB.chromaticAberration
            ? {
                offset: {
                    x: blend(presetA.chromaticAberration?.offset?.x, presetB.chromaticAberration?.offset?.x, 0.002),
                    y: blend(presetA.chromaticAberration?.offset?.y, presetB.chromaticAberration?.offset?.y, 0.002),
                },
            }
            : undefined,
        ssao: presetA.ssao || presetB.ssao
            ? {
                intensity: blend(presetA.ssao?.intensity, presetB.ssao?.intensity, 1),
                radius: blend(presetA.ssao?.radius, presetB.ssao?.radius, 0.1),
                luminanceInfluence: blend(presetA.ssao?.luminanceInfluence, presetB.ssao?.luminanceInfluence, 0.7),
            }
            : undefined,
        toneMapping: presetA.toneMapping || presetB.toneMapping
            ? {
                mode: clampedT < 0.5
                    ? (presetA.toneMapping?.mode ?? 1)
                    : (presetB.toneMapping?.mode ?? 1),
                exposure: blend(presetA.toneMapping?.exposure, presetB.toneMapping?.exposure, 1),
                whitePoint: blend(presetA.toneMapping?.whitePoint, presetB.toneMapping?.whitePoint, 4),
            }
            : undefined,
        brightnessContrast: presetA.brightnessContrast || presetB.brightnessContrast
            ? {
                brightness: blend(presetA.brightnessContrast?.brightness, presetB.brightnessContrast?.brightness, 0),
                contrast: blend(presetA.brightnessContrast?.contrast, presetB.brightnessContrast?.contrast, 0),
            }
            : undefined,
        sepia: presetA.sepia || presetB.sepia
            ? {
                intensity: blend(presetA.sepia?.intensity, presetB.sepia?.intensity, 1),
            }
            : undefined,
    };
}
/**
 * Calculate effect intensity based on time of day
 * @param hours Current hour (0-24)
 * @returns Object with recommended effect intensities
 */
export function getTimeOfDayEffects(hours) {
    const isGoldenHour = (hours >= 6 && hours <= 8) || (hours >= 17 && hours <= 19);
    const isNight = hours < 6 || hours > 20;
    return {
        bloomIntensity: isGoldenHour ? 1.5 : isNight ? 0.5 : 1.0,
        vignetteOffset: isNight ? 0.3 : 0.5,
        colorTemperature: isGoldenHour ? 0.2 : isNight ? -0.1 : 0,
    };
}
//# sourceMappingURL=postProcessing.js.map