/**
 * YukaJS Steering Behavior Hooks
 *
 * React hooks for creating and managing Yuka steering behaviors.
 * Use with YukaVehicle component to add AI behaviors.
 */
import { useEffect, useMemo } from 'react';
import * as YUKA from 'yuka';
// =============================================================================
// HELPER FUNCTIONS
// =============================================================================
function threeToYukaVector3(v) {
    if (Array.isArray(v)) {
        return new YUKA.Vector3(v[0], v[1], v[2]);
    }
    return new YUKA.Vector3(v.x, v.y, v.z);
}
export function useSeek(target, options = {}) {
    const { weight = 1 } = options;
    const behavior = useMemo(() => new YUKA.SeekBehavior(), []);
    useEffect(() => {
        behavior.weight = weight;
        if (target instanceof YUKA.Vector3) {
            behavior.target = target;
        }
        else if (target instanceof YUKA.GameEntity) {
            behavior.target = target.position;
        }
        else {
            behavior.target = threeToYukaVector3(target);
        }
    }, [behavior, target, weight]);
    return behavior;
}
export function useFlee(target, options = {}) {
    const { weight = 1, panicDistance = 10 } = options;
    const behavior = useMemo(() => new YUKA.FleeBehavior(), []);
    useEffect(() => {
        behavior.weight = weight;
        behavior.panicDistance = panicDistance;
        if (target instanceof YUKA.Vector3) {
            behavior.target = target;
        }
        else if (target instanceof YUKA.GameEntity) {
            behavior.target = target.position;
        }
        else {
            behavior.target = threeToYukaVector3(target);
        }
    }, [behavior, target, weight, panicDistance]);
    return behavior;
}
export function useArrive(target, options = {}) {
    const { weight = 1, deceleration = 3, tolerance = 0.1 } = options;
    const behavior = useMemo(() => new YUKA.ArriveBehavior(), []);
    useEffect(() => {
        behavior.weight = weight;
        behavior.deceleration = deceleration;
        behavior.tolerance = tolerance;
        if (target instanceof YUKA.Vector3) {
            behavior.target = target;
        }
        else if (target instanceof YUKA.GameEntity) {
            behavior.target = target.position;
        }
        else {
            behavior.target = threeToYukaVector3(target);
        }
    }, [behavior, target, weight, deceleration, tolerance]);
    return behavior;
}
export function usePursue(evader, options = {}) {
    const { weight = 1 } = options;
    const behavior = useMemo(() => new YUKA.PursuitBehavior(evader), [evader]);
    useEffect(() => {
        behavior.weight = weight;
        behavior.evader = evader;
    }, [behavior, evader, weight]);
    return behavior;
}
export function useEvade(pursuer, options = {}) {
    const { weight = 1, panicDistance = 10 } = options;
    const behavior = useMemo(() => new YUKA.EvadeBehavior(pursuer), [pursuer]);
    useEffect(() => {
        behavior.weight = weight;
        behavior.panicDistance = panicDistance;
        behavior.pursuer = pursuer;
    }, [behavior, pursuer, weight, panicDistance]);
    return behavior;
}
export function useWander(options = {}) {
    const { weight = 1, radius = 1, distance = 5, jitter = 5 } = options;
    const behavior = useMemo(() => new YUKA.WanderBehavior(), []);
    useEffect(() => {
        behavior.weight = weight;
        behavior.radius = radius;
        behavior.distance = distance;
        behavior.jitter = jitter;
    }, [behavior, weight, radius, distance, jitter]);
    return behavior;
}
export function useFollowPath(path, options = {}) {
    const { weight = 1, nextWaypointDistance = 1 } = options;
    const behavior = useMemo(() => new YUKA.FollowPathBehavior(path), [path]);
    useEffect(() => {
        behavior.weight = weight;
        behavior.nextWaypointDistance = nextWaypointDistance;
        behavior.path = path;
    }, [behavior, path, weight, nextWaypointDistance]);
    return behavior;
}
export function useSeparation(_entities = [], options = {}) {
    const { weight = 1 } = options;
    const behavior = useMemo(() => {
        return new YUKA.SeparationBehavior();
    }, []);
    useEffect(() => {
        behavior.weight = weight;
        // Note: In YUKA, flocking behaviors work with the vehicle's steering manager
        // The entities array should be registered with the EntityManager, not the behavior directly.
        // This hook returns the behavior; users should manage entity registration separately.
    }, [behavior, weight]);
    return behavior;
}
export function useAlignment(_entities = [], options = {}) {
    const { weight = 1 } = options;
    const behavior = useMemo(() => {
        return new YUKA.AlignmentBehavior();
    }, []);
    useEffect(() => {
        behavior.weight = weight;
        // Note: In YUKA, flocking behaviors work with the vehicle's steering manager
        // The entities array should be registered with the EntityManager, not the behavior directly.
        // This hook returns the behavior; users should manage entity registration separately.
    }, [behavior, weight]);
    return behavior;
}
export function useCohesion(_entities = [], options = {}) {
    const { weight = 1 } = options;
    const behavior = useMemo(() => {
        return new YUKA.CohesionBehavior();
    }, []);
    useEffect(() => {
        behavior.weight = weight;
        // Note: In YUKA, flocking behaviors work with the vehicle's steering manager
        // The entities array should be registered with the EntityManager, not the behavior directly.
        // This hook returns the behavior; users should manage entity registration separately.
    }, [behavior, weight]);
    return behavior;
}
export function useObstacleAvoidance(obstacles = [], options = {}) {
    const { weight = 1, dBoxMinLength = 4 } = options;
    const behavior = useMemo(() => {
        return new YUKA.ObstacleAvoidanceBehavior(obstacles);
    }, [obstacles]);
    useEffect(() => {
        behavior.weight = weight;
        behavior.dBoxMinLength = dBoxMinLength;
        behavior.obstacles = obstacles;
    }, [behavior, obstacles, weight, dBoxMinLength]);
    return behavior;
}
export function useOffsetPursuit(leader, offset, options = {}) {
    const { weight = 1 } = options;
    const behavior = useMemo(() => {
        const yukaOffset = offset instanceof YUKA.Vector3 ? offset : threeToYukaVector3(offset);
        return new YUKA.OffsetPursuitBehavior(leader, yukaOffset);
    }, [leader, offset]);
    useEffect(() => {
        behavior.weight = weight;
    }, [behavior, weight]);
    return behavior;
}
export function useInterpose(entity1, entity2, options = {}) {
    const { weight = 1 } = options;
    const behavior = useMemo(() => new YUKA.InterposeBehavior(entity1, entity2), [entity1, entity2]);
    useEffect(() => {
        behavior.weight = weight;
        behavior.entity1 = entity1;
        behavior.entity2 = entity2;
    }, [behavior, entity1, entity2, weight]);
    return behavior;
}
// =============================================================================
// RE-EXPORTS
// =============================================================================
// Re-export YUKA namespace for convenience
export { YUKA };
//# sourceMappingURL=useYuka.js.map