/**
 * Game State React Context and Core Hooks
 *
 * Provides React integration for Zustand-based game state management.
 * Uses the store directly without shadow copies.
 *
 * @module components/state/context
 */
import type React from 'react';
import type { GameStore } from '../../core/state';
import type { GameStateContextValue, GameStateProviderProps, PersistGateProps, StateDebuggerProps } from './types';
export declare const GameStateContext: React.Context<GameStateContextValue<any> | null>;
/**
 * Provides game state context to child components.
 *
 * Accepts either a pre-created store or creates one from initialState.
 *
 * @public
 * @param props - Provider configuration
 * @returns React context provider
 *
 * @example
 * ```tsx
 * // Option 1: Create store inline
 * <GameStateProvider initialState={{ health: 100 }}>
 *   <App />
 * </GameStateProvider>
 *
 * // Option 2: Pass pre-created store
 * const store = createGameStore({ health: 100 });
 * <GameStateProvider store={store}>
 *   <App />
 * </GameStateProvider>
 * ```
 */
export declare function GameStateProvider<T extends object>({ store: externalStore, initialState, config, onChange, children, }: GameStateProviderProps<T>): React.ReactElement;
/**
 * Access the game state store from context.
 *
 * @public
 * @returns The game store API
 *
 * @example
 * ```tsx
 * const { store } = useGameStateContext();
 * const data = store.getState().data;
 * ```
 */
export declare function useGameStateContext<T extends object>(): GameStateContextValue<T>;
/**
 * Subscribe to game state with an optional selector.
 *
 * @public
 * @param selector - Optional function to select a slice of state
 * @returns Selected state value or full store state
 *
 * @example
 * ```tsx
 * // Select specific data
 * const health = useGameState(s => s.data.health);
 *
 * // Get full store state (use sparingly)
 * const fullState = useGameState();
 * ```
 */
export declare function useGameState<T extends object, U = GameStore<T>>(selector?: (state: GameStore<T>) => U): U;
/**
 * Hook for undo/redo functionality.
 *
 * @public
 * @returns Undo/redo functions and state
 *
 * @example
 * ```tsx
 * const { undo, redo, canUndo, canRedo } = useUndo();
 *
 * return (
 *   <>
 *     <button onClick={undo} disabled={!canUndo}>Undo</button>
 *     <button onClick={redo} disabled={!canRedo}>Redo</button>
 *   </>
 * );
 * ```
 */
export declare function useUndo<T extends object>(): {
    undo: () => void;
    redo: () => void;
    canUndo: boolean;
    canRedo: boolean;
};
/**
 * Gate component that waits for state hydration before rendering children.
 *
 * @public
 * @param props - Gate configuration
 * @returns Loading indicator or children after hydration
 *
 * @example
 * ```tsx
 * <GameStateProvider initialState={defaultState}>
 *   <PersistGate loading={<Spinner />} storageKey="save1">
 *     <Game />
 *   </PersistGate>
 * </GameStateProvider>
 * ```
 */
export declare function PersistGate({ loading, storageKey, children, }: PersistGateProps): React.ReactElement;
/**
 * Debug panel for inspecting current game state.
 *
 * @public
 * @param props - Debugger configuration
 * @returns Debug overlay component
 *
 * @example
 * ```tsx
 * <GameStateProvider initialState={state}>
 *   <App />
 *   {process.env.NODE_ENV === 'development' && <StateDebugger />}
 * </GameStateProvider>
 * ```
 */
export declare function StateDebugger({ position, collapsed: initialCollapsed, }: StateDebuggerProps): React.ReactElement;
//# sourceMappingURL=context.d.ts.map