import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { createContext, useContext, useEffect, useMemo, useRef, useState } from 'react';
import { createGameStore } from '../../core/state';
export const GameStateContext = createContext(null);
/**
 * Provides game state context to child components.
 *
 * Accepts either a pre-created store or creates one from initialState.
 *
 * @public
 * @param props - Provider configuration
 * @returns React context provider
 *
 * @example
 * ```tsx
 * // Option 1: Create store inline
 * <GameStateProvider initialState={{ health: 100 }}>
 *   <App />
 * </GameStateProvider>
 *
 * // Option 2: Pass pre-created store
 * const store = createGameStore({ health: 100 });
 * <GameStateProvider store={store}>
 *   <App />
 * </GameStateProvider>
 * ```
 */
export function GameStateProvider({ store: externalStore, initialState, config, onChange, children, }) {
    const storeRef = useRef(null);
    if (!storeRef.current) {
        if (externalStore) {
            storeRef.current = externalStore;
        }
        else if (initialState) {
            storeRef.current = createGameStore(initialState, config);
        }
        else {
            throw new Error('GameStateProvider requires either store or initialState prop');
        }
    }
    useEffect(() => {
        if (!onChange)
            return;
        const store = storeRef.current;
        const unsubscribe = store.subscribe((newState, prevState) => {
            if (newState.data !== prevState.data) {
                onChange({
                    type: 'set',
                    previousValue: prevState.data,
                    currentValue: newState.data,
                    timestamp: Date.now(),
                });
            }
        });
        return unsubscribe;
    }, [onChange]);
    // Store reference is stable and set once, so empty deps is safe
    const value = useMemo(() => ({
        store: storeRef.current,
        // Kept for backwards compatibility
        useStore: storeRef.current,
    }), []);
    return _jsx(GameStateContext.Provider, { value: value, children: children });
}
/**
 * Access the game state store from context.
 *
 * @public
 * @returns The game store API
 *
 * @example
 * ```tsx
 * const { store } = useGameStateContext();
 * const data = store.getState().data;
 * ```
 */
export function useGameStateContext() {
    const context = useContext(GameStateContext);
    if (!context) {
        throw new Error('useGameStateContext must be used within a GameStateProvider');
    }
    return context;
}
/**
 * Subscribe to game state with an optional selector.
 *
 * @public
 * @param selector - Optional function to select a slice of state
 * @returns Selected state value or full store state
 *
 * @example
 * ```tsx
 * // Select specific data
 * const health = useGameState(s => s.data.health);
 *
 * // Get full store state (use sparingly)
 * const fullState = useGameState();
 * ```
 */
export function useGameState(selector) {
    const { store } = useGameStateContext();
    if (selector) {
        return store(selector);
    }
    return store();
}
/**
 * Hook for undo/redo functionality.
 *
 * @public
 * @returns Undo/redo functions and state
 *
 * @example
 * ```tsx
 * const { undo, redo, canUndo, canRedo } = useUndo();
 *
 * return (
 *   <>
 *     <button onClick={undo} disabled={!canUndo}>Undo</button>
 *     <button onClick={redo} disabled={!canRedo}>Redo</button>
 *   </>
 * );
 * ```
 */
export function useUndo() {
    const { store } = useGameStateContext();
    // Get stable function references once
    const { undo, redo } = store.getState();
    // Subscribe only to undo/redo availability, not entire state
    const canUndo = store((s) => s.canUndo());
    const canRedo = store((s) => s.canRedo());
    return { undo, redo, canUndo, canRedo };
}
/**
 * Gate component that waits for state hydration before rendering children.
 *
 * @public
 * @param props - Gate configuration
 * @returns Loading indicator or children after hydration
 *
 * @example
 * ```tsx
 * <GameStateProvider initialState={defaultState}>
 *   <PersistGate loading={<Spinner />} storageKey="save1">
 *     <Game />
 *   </PersistGate>
 * </GameStateProvider>
 * ```
 */
export function PersistGate({ loading, storageKey = 'default', children, }) {
    const { store } = useGameStateContext();
    const [isHydrated, setIsHydrated] = useState(false);
    useEffect(() => {
        let mounted = true;
        async function hydrate() {
            try {
                await store.getState().load(storageKey);
            }
            catch (error) {
                // Log error but start with fresh state
                console.error('Failed to hydrate state from storage:', error);
            }
            if (mounted) {
                setIsHydrated(true);
            }
        }
        hydrate();
        return () => {
            mounted = false;
        };
    }, [store, storageKey]);
    if (!isHydrated) {
        return _jsx(_Fragment, { children: loading ?? null });
    }
    return _jsx(_Fragment, { children: children });
}
/**
 * Debug panel for inspecting current game state.
 *
 * @public
 * @param props - Debugger configuration
 * @returns Debug overlay component
 *
 * @example
 * ```tsx
 * <GameStateProvider initialState={state}>
 *   <App />
 *   {process.env.NODE_ENV === 'development' && <StateDebugger />}
 * </GameStateProvider>
 * ```
 */
export function StateDebugger({ position = 'bottom-right', collapsed: initialCollapsed = true, }) {
    const { store } = useGameStateContext();
    const state = store();
    const [collapsed, setCollapsed] = useState(initialCollapsed);
    const positionStyles = {
        position: 'fixed',
        zIndex: 9999,
        ...(position.includes('top') ? { top: 16 } : { bottom: 16 }),
        ...(position.includes('left') ? { left: 16 } : { right: 16 }),
    };
    const containerStyles = {
        ...positionStyles,
        backgroundColor: 'rgba(0, 0, 0, 0.85)',
        color: '#fff',
        fontFamily: 'monospace',
        fontSize: '12px',
        borderRadius: '8px',
        boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
        overflow: 'hidden',
        maxWidth: collapsed ? 'auto' : '400px',
        maxHeight: collapsed ? 'auto' : '80vh',
    };
    const headerStyles = {
        padding: '8px 12px',
        backgroundColor: 'rgba(100, 100, 100, 0.3)',
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        gap: '12px',
    };
    const contentStyles = {
        padding: '12px',
        overflowY: 'auto',
        maxHeight: '60vh',
    };
    return (_jsxs("div", { style: containerStyles, children: [_jsxs("div", { style: headerStyles, onClick: () => setCollapsed(!collapsed), children: [_jsx("span", { style: { fontWeight: 'bold' }, children: "State Debugger" }), _jsx("span", { children: collapsed ? '▼' : '▲' })] }), !collapsed && (_jsxs("div", { style: contentStyles, children: [_jsx("div", { style: {
                            marginBottom: '12px',
                            padding: '8px',
                            backgroundColor: 'rgba(255,255,255,0.05)',
                            borderRadius: '4px',
                        }, children: _jsxs("div", { style: { marginBottom: '4px' }, children: [_jsx("span", { style: { color: '#888' }, children: "Undo: " }), _jsx("span", { style: { color: state.canUndo() ? '#4caf50' : '#666' }, children: state.canUndo() ? 'available' : 'none' }), _jsx("span", { style: { color: '#888' }, children: " | Redo: " }), _jsx("span", { style: { color: state.canRedo() ? '#4caf50' : '#666' }, children: state.canRedo() ? 'available' : 'none' })] }) }), _jsxs("div", { children: [_jsx("div", { style: { color: '#888', marginBottom: '4px' }, children: "Current Data:" }), _jsx("pre", { style: {
                                    margin: 0,
                                    whiteSpace: 'pre-wrap',
                                    wordBreak: 'break-word',
                                    color: '#e0e0e0',
                                    fontSize: '11px',
                                }, children: JSON.stringify(state.data, null, 2) })] })] }))] }));
}
//# sourceMappingURL=context.js.map