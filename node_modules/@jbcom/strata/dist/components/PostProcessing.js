import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
/**
 * Post-Processing React Components
 *
 * Higher-level components for applying post-processing effects using
 * @react-three/postprocessing. Provides preset-based effect stacks for
 * common visual styles.
 */
import { useFrame, useThree } from '@react-three/fiber';
import { Bloom, BrightnessContrast, ChromaticAberration, DepthOfField, EffectComposer, HueSaturation, Noise, Sepia, SSAO, ToneMapping, Vignette, } from '@react-three/postprocessing';
import { BlendFunction, ToneMappingMode } from 'postprocessing';
import { forwardRef, useImperativeHandle, useRef } from 'react';
import * as THREE from 'three';
import { calculateFocusDistanceToMesh } from '../core/postProcessing';
/**
 * EffectStack - Apply a preset configuration of effects
 */
export const EffectStack = ({ preset, enabled = true, multisampling = 8, children, }) => {
    if (!enabled)
        return null;
    const effects = [];
    if (preset.bloom) {
        effects.push(_jsx(Bloom, { intensity: preset.bloom.intensity ?? 1, luminanceThreshold: preset.bloom.luminanceThreshold ?? 0.9, luminanceSmoothing: preset.bloom.luminanceSmoothing ?? 0.025, mipmapBlur: preset.bloom.mipmapBlur ?? true }, "bloom"));
    }
    if (preset.dof) {
        effects.push(_jsx(DepthOfField, { focusDistance: preset.dof.focusDistance ?? 5, focalLength: preset.dof.focalLength ?? 50, bokehScale: preset.dof.bokehScale ?? 2 }, "dof"));
    }
    if (preset.vignette) {
        effects.push(_jsx(Vignette, { darkness: preset.vignette.darkness ?? 0.5, offset: preset.vignette.offset ?? 0.5 }, "vignette"));
    }
    if (preset.chromaticAberration) {
        effects.push(_jsx(ChromaticAberration, { offset: new THREE.Vector2(preset.chromaticAberration.offset?.x ?? 0.002, preset.chromaticAberration.offset?.y ?? 0.002), radialModulation: preset.chromaticAberration.radialModulation ?? true, modulationOffset: preset.chromaticAberration.modulationOffset ?? 0.15 }, "chromatic"));
    }
    if (preset.colorGrading) {
        effects.push(_jsx(HueSaturation, { hue: preset.colorGrading.hue ?? 0, saturation: preset.colorGrading.saturation ?? 0 }, "hueSat"));
    }
    if (preset.brightnessContrast) {
        effects.push(_jsx(BrightnessContrast, { brightness: preset.brightnessContrast.brightness ?? 0, contrast: preset.brightnessContrast.contrast ?? 0 }, "bc"));
    }
    if (preset.sepia) {
        effects.push(_jsx(Sepia, { intensity: preset.sepia.intensity ?? 1 }, "sepia"));
    }
    if (preset.filmGrain) {
        effects.push(_jsx(Noise, { premultiply: preset.noise?.premultiply ?? false, blendFunction: BlendFunction.ADD }, "noise"));
    }
    if (preset.toneMapping) {
        effects.push(_jsx(ToneMapping, { mode: preset.toneMapping.mode }, "toneMap"));
    }
    if (preset.ssao) {
        effects.push(_jsx(SSAO, { samples: preset.ssao.samples ?? 9, radius: preset.ssao.radius ?? 0.1, intensity: preset.ssao.intensity ?? 1, luminanceInfluence: preset.ssao.luminanceInfluence ?? 0.7, worldDistanceThreshold: 1, worldDistanceFalloff: 0.1, worldProximityThreshold: 0.5, worldProximityFalloff: 0.1 }, "ssao"));
    }
    return (_jsx(EffectComposer, { multisampling: multisampling, children: _jsxs(_Fragment, { children: [effects, children] }) }));
};
/**
 * CinematicEffects - Film-like look with bloom, vignette, chromatic aberration
 */
export const CinematicEffects = ({ bloomIntensity = 1, vignetteDarkness = 0.4, chromaticAberration = 0.003, filmGrain = true, enabled = true, multisampling = 8, }) => {
    if (!enabled)
        return null;
    const effects = [
        _jsx(Bloom, { intensity: bloomIntensity, luminanceThreshold: 0.85, luminanceSmoothing: 0.05, mipmapBlur: true }, "bloom"),
        _jsx(Vignette, { darkness: vignetteDarkness, offset: 0.4 }, "vignette"),
        _jsx(ChromaticAberration, { offset: new THREE.Vector2(chromaticAberration, chromaticAberration), radialModulation: true, modulationOffset: 0.2 }, "chromatic"),
    ];
    if (filmGrain) {
        effects.push(_jsx(Noise, { premultiply: true, blendFunction: BlendFunction.SOFT_LIGHT }, "noise"));
    }
    effects.push(_jsx(ToneMapping, { mode: ToneMappingMode.ACES_FILMIC }, "toneMap"));
    return _jsx(EffectComposer, { multisampling: multisampling, children: effects });
};
/**
 * DreamyEffects - Soft, ethereal look with high bloom and soft colors
 */
export const DreamyEffects = ({ bloomIntensity = 2, saturation = -0.2, brightness = 0.1, enabled = true, multisampling = 8, }) => {
    if (!enabled)
        return null;
    return (_jsxs(EffectComposer, { multisampling: multisampling, children: [_jsx(Bloom, { intensity: bloomIntensity, luminanceThreshold: 0.7, luminanceSmoothing: 0.1, mipmapBlur: true }), _jsx(HueSaturation, { hue: 0, saturation: saturation }), _jsx(BrightnessContrast, { brightness: brightness, contrast: -0.1 }), _jsx(Vignette, { darkness: 0.3, offset: 0.6 })] }));
};
/**
 * HorrorEffects - Desaturated, noisy, dark atmosphere
 */
export const HorrorEffects = ({ desaturation = -0.5, noiseIntensity = 0.2, vignetteDarkness = 0.7, chromaticAberration = true, enabled = true, multisampling = 8, }) => {
    if (!enabled)
        return null;
    const effects = [
        _jsx(HueSaturation, { hue: 0, saturation: desaturation }, "hueSat"),
        _jsx(BrightnessContrast, { brightness: -0.15, contrast: 0.2 }, "bc"),
        _jsx(Vignette, { darkness: vignetteDarkness, offset: 0.3 }, "vignette"),
        _jsx(Noise, { premultiply: true, blendFunction: BlendFunction.ADD }, "noise"),
    ];
    if (chromaticAberration) {
        effects.push(_jsx(ChromaticAberration, { offset: new THREE.Vector2(0.005, 0.005), radialModulation: true, modulationOffset: 0.3 }, "chromatic"));
    }
    return _jsx(EffectComposer, { multisampling: multisampling, children: effects });
};
/**
 * NeonEffects - High bloom, saturated colors for cyberpunk/neon aesthetics
 */
export const NeonEffects = ({ bloomIntensity = 3, saturation = 0.3, luminanceThreshold = 0.6, enabled = true, multisampling = 8, }) => {
    if (!enabled)
        return null;
    return (_jsxs(EffectComposer, { multisampling: multisampling, children: [_jsx(Bloom, { intensity: bloomIntensity, luminanceThreshold: luminanceThreshold, luminanceSmoothing: 0.05, mipmapBlur: true }), _jsx(HueSaturation, { hue: 0, saturation: saturation }), _jsx(BrightnessContrast, { brightness: 0, contrast: 0.15 }), _jsx(ToneMapping, { mode: ToneMappingMode.REINHARD2 })] }));
};
/**
 * RealisticEffects - Subtle, physically-based rendering enhancements
 */
export const RealisticEffects = ({ ssao = true, ssaoIntensity = 1, bloomIntensity = 0.5, toneMappingMode = ToneMappingMode.ACES_FILMIC, enabled = true, multisampling = 8, }) => {
    if (!enabled)
        return null;
    const effects = [];
    if (ssao) {
        effects.push(_jsx(SSAO, { samples: 16, radius: 0.05, intensity: ssaoIntensity, luminanceInfluence: 0.5, worldDistanceThreshold: 1, worldDistanceFalloff: 0.1, worldProximityThreshold: 0.5, worldProximityFalloff: 0.1 }, "ssao"));
    }
    effects.push(_jsx(Bloom, { intensity: bloomIntensity, luminanceThreshold: 0.95, luminanceSmoothing: 0.01, mipmapBlur: true }, "bloom"), _jsx(ToneMapping, { mode: toneMappingMode }, "toneMap"));
    return _jsx(EffectComposer, { multisampling: multisampling, children: effects });
};
/**
 * VintageEffects - Old film/photograph look
 */
export const VintageEffects = ({ sepiaIntensity = 0.4, vignetteDarkness = 0.5, filmGrain = true, saturation = -0.3, enabled = true, multisampling = 8, }) => {
    if (!enabled)
        return null;
    const effects = [
        _jsx(HueSaturation, { hue: 0.05, saturation: saturation }, "hueSat"),
        _jsx(Sepia, { intensity: sepiaIntensity }, "sepia"),
        _jsx(BrightnessContrast, { brightness: -0.05, contrast: 0.1 }, "bc"),
        _jsx(Vignette, { darkness: vignetteDarkness, offset: 0.4 }, "vignette"),
    ];
    if (filmGrain) {
        effects.push(_jsx(Noise, { premultiply: true, blendFunction: BlendFunction.SOFT_LIGHT }, "noise"));
    }
    return _jsx(EffectComposer, { multisampling: multisampling, children: effects });
};
/**
 * DynamicDOF - Depth of field that follows a target object
 */
export const DynamicDOF = forwardRef(({ target, focusDistance: fixedFocusDistance = 5, focalLength = 50, bokehScale = 2, focusSpeed = 5, enabled = true, multisampling = 8, }, ref) => {
    const { camera } = useThree();
    const focusDistanceRef = useRef(fixedFocusDistance);
    const targetFocusRef = useRef(fixedFocusDistance);
    useImperativeHandle(ref, () => ({
        focusOnTarget: (newTarget) => {
            targetFocusRef.current = calculateFocusDistanceToMesh(camera, newTarget);
        },
        getFocusDistance: () => focusDistanceRef.current,
    }));
    useFrame((_, delta) => {
        if (target?.current) {
            targetFocusRef.current = calculateFocusDistanceToMesh(camera, target.current);
        }
        const diff = targetFocusRef.current - focusDistanceRef.current;
        focusDistanceRef.current += diff * focusSpeed * delta;
    });
    if (!enabled)
        return null;
    return (_jsx(EffectComposer, { multisampling: multisampling, children: _jsx(DepthOfField, { focusDistance: focusDistanceRef.current, focalLength: focalLength, bokehScale: bokehScale }) }));
});
DynamicDOF.displayName = 'DynamicDOF';
/**
 * MotionBlurEffect - Camera motion blur effect
 * Note: This uses camera motion blur. Per-object motion blur requires velocity buffers.
 */
export const MotionBlurEffect = ({ intensity = 0.5, jitter = 0.5, samples = 9, enabled = true, multisampling = 8, }) => {
    if (!enabled)
        return null;
    return (_jsx(EffectComposer, { multisampling: multisampling, children: _jsx(Bloom, { intensity: intensity * 0.2, luminanceThreshold: 0.99, mipmapBlur: true }) }));
};
//# sourceMappingURL=PostProcessing.js.map