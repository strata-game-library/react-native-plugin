/**
 * YukaJS React Component Wrappers
 *
 * Integrates Yuka game AI library with React Three Fiber.
 * Provides steering behaviors, pathfinding, FSM, and perception.
 * @module components/AI
 */
import type React from 'react';
import { type ReactNode } from 'react';
import * as THREE from 'three';
import * as YUKA from 'yuka';
/**
 * Context value provided by YukaEntityManager
 *
 * @property manager - The Yuka EntityManager instance
 * @property time - Yuka Time instance for delta time
 * @property register - Function to register entities
 * @property unregister - Function to unregister entities
 */
export interface YukaEntityManagerContextValue {
    manager: YUKA.EntityManager;
    time: YUKA.Time;
    register: (entity: YUKA.GameEntity) => void;
    unregister: (entity: YUKA.GameEntity) => void;
}
/**
 * Props for the YukaVehicle component
 *
 * @property maxSpeed - Maximum speed of the vehicle
 * @property maxForce - Maximum steering force
 * @property mass - Mass affecting momentum
 * @property position - Initial position [x, y, z]
 * @property rotation - Initial rotation [x, y, z]
 * @property children - Child components to render
 * @property onUpdate - Callback called each frame with vehicle and delta
 */
export interface YukaVehicleProps {
    maxSpeed?: number;
    maxForce?: number;
    mass?: number;
    position?: [number, number, number];
    rotation?: [number, number, number];
    children?: ReactNode;
    onUpdate?: (vehicle: YUKA.Vehicle, delta: number) => void;
}
/**
 * Ref interface for YukaVehicle imperative control
 *
 * @property vehicle - The underlying Yuka Vehicle instance
 * @property addBehavior - Add a steering behavior
 * @property removeBehavior - Remove a steering behavior
 * @property clearBehaviors - Remove all behaviors
 */
export interface YukaVehicleRef {
    vehicle: YUKA.Vehicle;
    addBehavior: (behavior: YUKA.SteeringBehavior) => void;
    removeBehavior: (behavior: YUKA.SteeringBehavior) => void;
    clearBehaviors: () => void;
}
/**
 * Props for the YukaPath component
 *
 * @property waypoints - Array of waypoint positions [[x,y,z], ...]
 * @property loop - Whether the path loops back to start
 * @property visible - Show path visualization
 * @property color - Color of the path line
 * @property lineWidth - Width of the path line
 * @property showWaypoints - Show small spheres at waypoint positions
 * @property waypointSize - Size of waypoint spheres (default: 0.2)
 * @property waypointColor - Color of waypoint spheres
 * @property showDirection - Show direction arrows between waypoints
 */
export interface YukaPathProps {
    waypoints: Array<[number, number, number]>;
    loop?: boolean;
    visible?: boolean;
    color?: THREE.ColorRepresentation;
    lineWidth?: number;
    showWaypoints?: boolean;
    waypointSize?: number;
    waypointColor?: THREE.ColorRepresentation;
    showDirection?: boolean;
}
/**
 * Ref interface for YukaPath
 *
 * @property path - The underlying Yuka Path instance
 */
export interface YukaPathRef {
    path: YUKA.Path;
}
/**
 * Configuration for a state in the state machine
 *
 * @property name - Unique state name
 * @property onEnter - Called when entering this state
 * @property onExecute - Called each frame while in this state
 * @property onExit - Called when exiting this state
 */
export interface StateConfig {
    name: string;
    onEnter?: (entity: YUKA.GameEntity) => void;
    onExecute?: (entity: YUKA.GameEntity) => void;
    onExit?: (entity: YUKA.GameEntity) => void;
}
/**
 * Props for the YukaStateMachine component
 *
 * @property entity - The entity this state machine controls
 * @property states - Array of state configurations
 * @property initialState - Name of the starting state
 * @property globalState - Optional state that runs alongside current state
 */
export interface YukaStateMachineProps {
    entity?: YUKA.GameEntity;
    states: StateConfig[];
    initialState: string;
    globalState?: StateConfig;
}
/**
 * Ref interface for YukaStateMachine imperative control
 *
 * @property stateMachine - The underlying Yuka StateMachine
 * @property changeTo - Transition to a named state
 * @property revert - Return to previous state
 * @property getCurrentState - Get current state name
 */
export interface YukaStateMachineRef {
    stateMachine: YUKA.StateMachine<YUKA.GameEntity>;
    changeTo: (stateName: string) => void;
    revert: () => void;
    getCurrentState: () => string | null;
}
/**
 * Props for the YukaNavMesh component
 *
 * @property geometry - Three.js geometry to create nav mesh from
 * @property visible - Show nav mesh visualization
 * @property wireframe - Show as wireframe
 * @property color - Color of the visualization
 */
export interface YukaNavMeshProps {
    geometry: THREE.BufferGeometry;
    visible?: boolean;
    wireframe?: boolean;
    color?: THREE.ColorRepresentation;
}
/**
 * Ref interface for YukaNavMesh imperative control
 *
 * @property navMesh - The underlying Yuka NavMesh
 * @property findPath - Find path between two points
 * @property getRandomRegion - Get a random walkable region
 * @property getClosestRegion - Get closest region to a point
 */
export interface YukaNavMeshRef {
    navMesh: YUKA.NavMesh;
    findPath: (from: THREE.Vector3, to: THREE.Vector3) => THREE.Vector3[];
    getRandomRegion: () => YUKA.Polygon | null;
    getClosestRegion: (point: THREE.Vector3) => YUKA.Polygon | null;
}
/**
 * Hook to access the Yuka context within a YukaEntityManager.
 * Must be used inside a YukaEntityManager component tree.
 *
 * @example
 * ```tsx
 * function AIComponent() {
 *   const { manager, register } = useYukaContext();
 *   // Access Yuka functionality
 * }
 * ```
 *
 * @returns YukaEntityManagerContextValue with manager and registration functions
 * @throws Error if used outside YukaEntityManager
 */
export declare function useYukaContext(): YukaEntityManagerContextValue;
declare function syncYukaToThree(yukaEntity: YUKA.GameEntity, threeObject: THREE.Object3D): void;
declare function yukaVector3ToThree(yukaVec: YUKA.Vector3): THREE.Vector3;
declare function threeVector3ToYuka(threeVec: THREE.Vector3): YUKA.Vector3;
/**
 * Props for the YukaEntityManager component
 *
 * @property children - Child components that can use Yuka AI
 */
export interface YukaEntityManagerProps {
    children?: ReactNode;
}
/**
 * Context provider that manages Yuka AI entities and updates them each frame.
 * Must wrap all Yuka-related components in your scene.
 *
 * @example
 * ```tsx
 * <Canvas>
 *   <YukaEntityManager>
 *     <YukaVehicle maxSpeed={5}>
 *       <mesh>
 *         <boxGeometry />
 *         <meshStandardMaterial />
 *       </mesh>
 *     </YukaVehicle>
 *     <YukaPath waypoints={[[0,0,0], [10,0,0], [10,0,10]]} />
 *   </YukaEntityManager>
 * </Canvas>
 * ```
 *
 * @param props - YukaEntityManagerProps
 * @returns Provider component for Yuka AI context
 */
export declare function YukaEntityManager({ children }: YukaEntityManagerProps): React.JSX.Element;
/**
 * Autonomous vehicle agent with steering behaviors.
 * Syncs Yuka AI transforms to Three.js objects automatically.
 *
 * @example
 * ```tsx
 * // Basic wandering agent
 * const vehicleRef = useRef<YukaVehicleRef>(null);
 *
 * useEffect(() => {
 *   const wander = new YUKA.WanderBehavior();
 *   vehicleRef.current?.addBehavior(wander);
 * }, []);
 *
 * <YukaVehicle
 *   ref={vehicleRef}
 *   maxSpeed={3}
 *   position={[0, 0, 0]}
 * >
 *   <mesh><boxGeometry /></mesh>
 * </YukaVehicle>
 *
 * // Path following agent
 * <YukaVehicle
 *   maxSpeed={5}
 *   onUpdate={(vehicle) => {
 *     const follow = new YUKA.FollowPathBehavior(path);
 *     vehicle.steering.add(follow);
 *   }}
 * >
 *   <EnemyModel />
 * </YukaVehicle>
 * ```
 *
 * @param props - YukaVehicleProps configuration
 * @returns React element containing the vehicle group
 */
export declare const YukaVehicle: React.ForwardRefExoticComponent<YukaVehicleProps & React.RefAttributes<YukaVehicleRef>>;
/**
 * Path definition component for AI agents to follow.
 * Provides waypoints for FollowPathBehavior and path visualization.
 *
 * @example
 * ```tsx
 * // Patrol path with visualization
 * const pathRef = useRef<YukaPathRef>(null);
 *
 * <YukaPath
 *   ref={pathRef}
 *   waypoints={[
 *     [0, 0, 0],
 *     [10, 0, 0],
 *     [10, 0, 10],
 *     [0, 0, 10]
 *   ]}
 *   loop={true}
 *   visible={true}
 *   color="#00ff00"
 *   showWaypoints={true}
 *   showDirection={true}
 * />
 *
 * // Use with FollowPathBehavior
 * useEffect(() => {
 *   const follow = new YUKA.FollowPathBehavior(pathRef.current.path);
 *   vehicleRef.current?.addBehavior(follow);
 * }, []);
 * ```
 *
 * @param props - YukaPathProps configuration
 * @returns React element with optional path visualization
 */
export declare const YukaPath: React.ForwardRefExoticComponent<YukaPathProps & React.RefAttributes<YukaPathRef>>;
/**
 * Finite State Machine component for AI behavior control.
 * Manages state transitions with enter/execute/exit callbacks.
 *
 * @example
 * ```tsx
 * // Enemy AI with patrol and chase states
 * const stateRef = useRef<YukaStateMachineRef>(null);
 *
 * const states: StateConfig[] = [
 *   {
 *     name: 'patrol',
 *     onEnter: () => console.log('Starting patrol'),
 *     onExecute: (entity) => {
 *       if (canSeePlayer(entity)) {
 *         stateRef.current?.changeTo('chase');
 *       }
 *     }
 *   },
 *   {
 *     name: 'chase',
 *     onEnter: () => console.log('Chasing player!'),
 *     onExecute: (entity) => {
 *       if (!canSeePlayer(entity)) {
 *         stateRef.current?.revert();
 *       }
 *     }
 *   }
 * ];
 *
 * <YukaStateMachine
 *   ref={stateRef}
 *   states={states}
 *   initialState="patrol"
 * />
 * ```
 *
 * @param props - YukaStateMachineProps configuration
 * @returns null (logic only component)
 */
export declare const YukaStateMachine: React.ForwardRefExoticComponent<YukaStateMachineProps & React.RefAttributes<YukaStateMachineRef>>;
/**
 * Navigation mesh component for AI pathfinding.
 * Creates a walkable surface from Three.js geometry for A* pathfinding.
 *
 * @example
 * ```tsx
 * // Create nav mesh from floor geometry
 * const navMeshRef = useRef<YukaNavMeshRef>(null);
 *
 * <YukaNavMesh
 *   ref={navMeshRef}
 *   geometry={floorGeometry}
 *   visible={debugMode}
 *   wireframe={true}
 *   color="#0088ff"
 * />
 *
 * // Find path for AI movement
 * const handleClick = (target: THREE.Vector3) => {
 *   const path = navMeshRef.current?.findPath(
 *     agentPosition,
 *     target
 *   );
 *   if (path) {
 *     moveAlongPath(path);
 *   }
 * };
 *
 * // Get random patrol point
 * const getPatrolPoint = () => {
 *   const region = navMeshRef.current?.getRandomRegion();
 *   return region?.centroid;
 * };
 * ```
 *
 * @param props - YukaNavMeshProps configuration
 * @returns React element with optional nav mesh visualization
 */
export declare const YukaNavMesh: React.ForwardRefExoticComponent<YukaNavMeshProps & React.RefAttributes<YukaNavMeshRef>>;
export { yukaVector3ToThree, threeVector3ToYuka, syncYukaToThree };
//# sourceMappingURL=AI.d.ts.map