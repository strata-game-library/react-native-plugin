import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 * YukaJS React Component Wrappers
 *
 * Integrates Yuka game AI library with React Three Fiber.
 * Provides steering behaviors, pathfinding, FSM, and perception.
 * @module components/AI
 */
import { Line } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import { createContext, forwardRef, useContext, useEffect, useImperativeHandle, useMemo, useRef, } from 'react';
import * as THREE from 'three';
import * as YUKA from 'yuka';
const YukaContext = createContext(null);
/**
 * Hook to access the Yuka context within a YukaEntityManager.
 * Must be used inside a YukaEntityManager component tree.
 *
 * @example
 * ```tsx
 * function AIComponent() {
 *   const { manager, register } = useYukaContext();
 *   // Access Yuka functionality
 * }
 * ```
 *
 * @returns YukaEntityManagerContextValue with manager and registration functions
 * @throws Error if used outside YukaEntityManager
 */
export function useYukaContext() {
    const context = useContext(YukaContext);
    if (!context) {
        throw new Error('useYukaContext must be used within a YukaEntityManager');
    }
    return context;
}
function syncYukaToThree(yukaEntity, threeObject) {
    const matrix = yukaEntity.worldMatrix;
    threeObject.matrix.set(matrix.elements[0], matrix.elements[3], matrix.elements[6], 0, matrix.elements[1], matrix.elements[4], matrix.elements[7], 0, matrix.elements[2], matrix.elements[5], matrix.elements[8], 0, yukaEntity.position.x, yukaEntity.position.y, yukaEntity.position.z, 1);
    threeObject.matrixAutoUpdate = false;
    threeObject.matrixWorldNeedsUpdate = true;
}
function yukaVector3ToThree(yukaVec) {
    return new THREE.Vector3(yukaVec.x, yukaVec.y, yukaVec.z);
}
function threeVector3ToYuka(threeVec) {
    return new YUKA.Vector3(threeVec.x, threeVec.y, threeVec.z);
}
/**
 * Context provider that manages Yuka AI entities and updates them each frame.
 * Must wrap all Yuka-related components in your scene.
 *
 * @example
 * ```tsx
 * <Canvas>
 *   <YukaEntityManager>
 *     <YukaVehicle maxSpeed={5}>
 *       <mesh>
 *         <boxGeometry />
 *         <meshStandardMaterial />
 *       </mesh>
 *     </YukaVehicle>
 *     <YukaPath waypoints={[[0,0,0], [10,0,0], [10,0,10]]} />
 *   </YukaEntityManager>
 * </Canvas>
 * ```
 *
 * @param props - YukaEntityManagerProps
 * @returns Provider component for Yuka AI context
 */
export function YukaEntityManager({ children }) {
    const managerRef = useRef(new YUKA.EntityManager());
    const timeRef = useRef(new YUKA.Time());
    const register = (entity) => {
        managerRef.current.add(entity);
    };
    const unregister = (entity) => {
        managerRef.current.remove(entity);
    };
    useFrame(() => {
        const delta = timeRef.current.update().getDelta();
        managerRef.current.update(delta);
    });
    const contextValue = useMemo(() => ({
        manager: managerRef.current,
        time: timeRef.current,
        register,
        unregister,
    }), [register, unregister]);
    return _jsx(YukaContext.Provider, { value: contextValue, children: children });
}
/**
 * Autonomous vehicle agent with steering behaviors.
 * Syncs Yuka AI transforms to Three.js objects automatically.
 *
 * @example
 * ```tsx
 * // Basic wandering agent
 * const vehicleRef = useRef<YukaVehicleRef>(null);
 *
 * useEffect(() => {
 *   const wander = new YUKA.WanderBehavior();
 *   vehicleRef.current?.addBehavior(wander);
 * }, []);
 *
 * <YukaVehicle
 *   ref={vehicleRef}
 *   maxSpeed={3}
 *   position={[0, 0, 0]}
 * >
 *   <mesh><boxGeometry /></mesh>
 * </YukaVehicle>
 *
 * // Path following agent
 * <YukaVehicle
 *   maxSpeed={5}
 *   onUpdate={(vehicle) => {
 *     const follow = new YUKA.FollowPathBehavior(path);
 *     vehicle.steering.add(follow);
 *   }}
 * >
 *   <EnemyModel />
 * </YukaVehicle>
 * ```
 *
 * @param props - YukaVehicleProps configuration
 * @returns React element containing the vehicle group
 */
export const YukaVehicle = forwardRef(function YukaVehicle({ maxSpeed = 5, maxForce = 10, mass = 1, position = [0, 0, 0], rotation = [0, 0, 0], children, onUpdate, }, ref) {
    const { register, unregister } = useYukaContext();
    const groupRef = useRef(null);
    const vehicleRef = useRef(new YUKA.Vehicle());
    useEffect(() => {
        const vehicle = vehicleRef.current;
        vehicle.maxSpeed = maxSpeed;
        vehicle.maxForce = maxForce;
        vehicle.mass = mass;
        vehicle.position.set(position[0], position[1], position[2]);
        const euler = new THREE.Euler(rotation[0], rotation[1], rotation[2]);
        const quaternion = new THREE.Quaternion().setFromEuler(euler);
        vehicle.rotation.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
        register(vehicle);
        return () => {
            unregister(vehicle);
        };
    }, [register, unregister, maxSpeed, maxForce, mass, position, rotation]);
    useFrame((_, delta) => {
        const vehicle = vehicleRef.current;
        const group = groupRef.current;
        if (group) {
            syncYukaToThree(vehicle, group);
        }
        if (onUpdate) {
            onUpdate(vehicle, delta);
        }
    });
    useImperativeHandle(ref, () => ({
        vehicle: vehicleRef.current,
        addBehavior: (behavior) => {
            vehicleRef.current.steering.add(behavior);
        },
        removeBehavior: (behavior) => {
            vehicleRef.current.steering.remove(behavior);
        },
        clearBehaviors: () => {
            vehicleRef.current.steering.clear();
        },
    }), []);
    return _jsx("group", { ref: groupRef, children: children });
});
/**
 * Path definition component for AI agents to follow.
 * Provides waypoints for FollowPathBehavior and path visualization.
 *
 * @example
 * ```tsx
 * // Patrol path with visualization
 * const pathRef = useRef<YukaPathRef>(null);
 *
 * <YukaPath
 *   ref={pathRef}
 *   waypoints={[
 *     [0, 0, 0],
 *     [10, 0, 0],
 *     [10, 0, 10],
 *     [0, 0, 10]
 *   ]}
 *   loop={true}
 *   visible={true}
 *   color="#00ff00"
 *   showWaypoints={true}
 *   showDirection={true}
 * />
 *
 * // Use with FollowPathBehavior
 * useEffect(() => {
 *   const follow = new YUKA.FollowPathBehavior(pathRef.current.path);
 *   vehicleRef.current?.addBehavior(follow);
 * }, []);
 * ```
 *
 * @param props - YukaPathProps configuration
 * @returns React element with optional path visualization
 */
export const YukaPath = forwardRef(function YukaPath({ waypoints, loop = false, visible = false, color = 0x00ff00, lineWidth = 2, showWaypoints = false, waypointSize = 0.2, waypointColor, showDirection = false, }, ref) {
    const pathRef = useRef(new YUKA.Path());
    useEffect(() => {
        const path = pathRef.current;
        path.clear();
        path.loop = loop;
        for (const [x, y, z] of waypoints) {
            path.add(new YUKA.Vector3(x, y, z));
        }
    }, [waypoints, loop]);
    useImperativeHandle(ref, () => ({
        path: pathRef.current,
    }), []);
    const linePoints = useMemo(() => {
        if (!visible || waypoints.length < 2)
            return null;
        const points = [...waypoints];
        if (loop && points.length > 2) {
            points.push(waypoints[0]);
        }
        return points;
    }, [waypoints, loop, visible]);
    const directionArrows = useMemo(() => {
        if (!showDirection || !visible || waypoints.length < 2)
            return [];
        const arrows = [];
        const pointCount = loop ? waypoints.length : waypoints.length - 1;
        for (let i = 0; i < pointCount; i++) {
            const from = waypoints[i];
            const to = waypoints[(i + 1) % waypoints.length];
            const midX = (from[0] + to[0]) / 2;
            const midY = (from[1] + to[1]) / 2;
            const midZ = (from[2] + to[2]) / 2;
            const dx = to[0] - from[0];
            const dy = to[1] - from[1];
            const dz = to[2] - from[2];
            const yaw = Math.atan2(dx, dz);
            const pitch = Math.atan2(dy, Math.sqrt(dx * dx + dz * dz));
            arrows.push({
                position: [midX, midY, midZ],
                rotation: [pitch, yaw, 0],
            });
        }
        return arrows;
    }, [waypoints, loop, showDirection, visible]);
    const effectiveWaypointColor = waypointColor ?? color;
    if (!visible) {
        return null;
    }
    return (_jsxs("group", { children: [linePoints && linePoints.length >= 2 && (_jsx(Line, { points: linePoints, color: color, lineWidth: lineWidth })), showWaypoints &&
                waypoints.map((wp, index) => (_jsxs("mesh", { position: wp, children: [_jsx("sphereGeometry", { args: [waypointSize, 8, 8] }), _jsx("meshBasicMaterial", { color: effectiveWaypointColor })] }, `waypoint-${index}`))), showDirection &&
                directionArrows.map((arrow, index) => (_jsxs("mesh", { position: arrow.position, rotation: arrow.rotation, children: [_jsx("coneGeometry", { args: [waypointSize * 0.5, waypointSize * 1.5, 6] }), _jsx("meshBasicMaterial", { color: color })] }, `arrow-${index}`)))] }));
});
class YukaState extends YUKA.State {
    name;
    _onEnter;
    _onExecute;
    _onExit;
    constructor(config) {
        super();
        this.name = config.name;
        this._onEnter = config.onEnter;
        this._onExecute = config.onExecute;
        this._onExit = config.onExit;
    }
    enter(entity) {
        if (this._onEnter)
            this._onEnter(entity);
    }
    execute(entity) {
        if (this._onExecute)
            this._onExecute(entity);
    }
    exit(entity) {
        if (this._onExit)
            this._onExit(entity);
    }
}
/**
 * Finite State Machine component for AI behavior control.
 * Manages state transitions with enter/execute/exit callbacks.
 *
 * @example
 * ```tsx
 * // Enemy AI with patrol and chase states
 * const stateRef = useRef<YukaStateMachineRef>(null);
 *
 * const states: StateConfig[] = [
 *   {
 *     name: 'patrol',
 *     onEnter: () => console.log('Starting patrol'),
 *     onExecute: (entity) => {
 *       if (canSeePlayer(entity)) {
 *         stateRef.current?.changeTo('chase');
 *       }
 *     }
 *   },
 *   {
 *     name: 'chase',
 *     onEnter: () => console.log('Chasing player!'),
 *     onExecute: (entity) => {
 *       if (!canSeePlayer(entity)) {
 *         stateRef.current?.revert();
 *       }
 *     }
 *   }
 * ];
 *
 * <YukaStateMachine
 *   ref={stateRef}
 *   states={states}
 *   initialState="patrol"
 * />
 * ```
 *
 * @param props - YukaStateMachineProps configuration
 * @returns null (logic only component)
 */
export const YukaStateMachine = forwardRef(function YukaStateMachine({ entity, states, initialState, globalState }, ref) {
    const stateMachineRef = useRef(null);
    const statesMapRef = useRef(new Map());
    const dummyEntityRef = useRef(new YUKA.GameEntity());
    useEffect(() => {
        const targetEntity = entity || dummyEntityRef.current;
        const sm = new YUKA.StateMachine(targetEntity);
        stateMachineRef.current = sm;
        statesMapRef.current.clear();
        for (const config of states) {
            const state = new YukaState(config);
            statesMapRef.current.set(config.name, state);
        }
        if (globalState) {
            sm.globalState = new YukaState(globalState);
        }
        const initial = statesMapRef.current.get(initialState);
        if (initial) {
            sm.currentState = initial;
            initial.enter(targetEntity);
        }
        return () => {
            stateMachineRef.current = null;
        };
    }, [entity, states, initialState, globalState]);
    useFrame(() => {
        if (stateMachineRef.current) {
            stateMachineRef.current.update();
        }
    });
    useImperativeHandle(ref, () => ({
        // Use getter to return current value instead of captured null
        get stateMachine() {
            return stateMachineRef.current;
        },
        changeTo: (stateName) => {
            const sm = stateMachineRef.current;
            const state = statesMapRef.current.get(stateName);
            if (sm && state) {
                sm.changeTo(state);
            }
        },
        revert: () => {
            stateMachineRef.current?.revert();
        },
        getCurrentState: () => {
            const current = stateMachineRef.current?.currentState;
            if (current && current instanceof YukaState) {
                return current.name;
            }
            return null;
        },
    }), []);
    return null;
});
/**
 * Navigation mesh component for AI pathfinding.
 * Creates a walkable surface from Three.js geometry for A* pathfinding.
 *
 * @example
 * ```tsx
 * // Create nav mesh from floor geometry
 * const navMeshRef = useRef<YukaNavMeshRef>(null);
 *
 * <YukaNavMesh
 *   ref={navMeshRef}
 *   geometry={floorGeometry}
 *   visible={debugMode}
 *   wireframe={true}
 *   color="#0088ff"
 * />
 *
 * // Find path for AI movement
 * const handleClick = (target: THREE.Vector3) => {
 *   const path = navMeshRef.current?.findPath(
 *     agentPosition,
 *     target
 *   );
 *   if (path) {
 *     moveAlongPath(path);
 *   }
 * };
 *
 * // Get random patrol point
 * const getPatrolPoint = () => {
 *   const region = navMeshRef.current?.getRandomRegion();
 *   return region?.centroid;
 * };
 * ```
 *
 * @param props - YukaNavMeshProps configuration
 * @returns React element with optional nav mesh visualization
 */
export const YukaNavMesh = forwardRef(function YukaNavMesh({ geometry, visible = false, wireframe = true, color = 0x0088ff }, ref) {
    const navMeshRef = useRef(new YUKA.NavMesh());
    const meshRef = useRef(null);
    useEffect(() => {
        const navMesh = navMeshRef.current;
        const positionAttr = geometry.getAttribute('position');
        const indexAttr = geometry.getIndex();
        if (!positionAttr)
            return;
        const vertices = [];
        for (let i = 0; i < positionAttr.count; i++) {
            vertices.push(positionAttr.getX(i), positionAttr.getY(i), positionAttr.getZ(i));
        }
        const indices = [];
        if (indexAttr) {
            for (let i = 0; i < indexAttr.count; i++) {
                indices.push(indexAttr.getX(i));
            }
        }
        else {
            for (let i = 0; i < positionAttr.count; i++) {
                indices.push(i);
            }
        }
        navMesh.fromPolygons(createPolygonsFromGeometry(vertices, indices));
    }, [geometry]);
    useImperativeHandle(ref, () => ({
        navMesh: navMeshRef.current,
        findPath: (from, to) => {
            const fromYuka = threeVector3ToYuka(from);
            const toYuka = threeVector3ToYuka(to);
            const path = navMeshRef.current.findPath(fromYuka, toYuka);
            return path.map((p) => yukaVector3ToThree(p));
        },
        getRandomRegion: () => {
            const regions = navMeshRef.current.regions;
            if (regions.length === 0)
                return null;
            return regions[Math.floor(Math.random() * regions.length)];
        },
        getClosestRegion: (point) => {
            const yukaPoint = threeVector3ToYuka(point);
            return navMeshRef.current.getClosestRegion(yukaPoint);
        },
    }), []);
    if (!visible) {
        return null;
    }
    return (_jsxs("mesh", { ref: meshRef, children: [_jsx("primitive", { object: geometry, attach: "geometry" }), _jsx("meshBasicMaterial", { color: color, wireframe: wireframe, transparent: true, opacity: 0.5, side: THREE.DoubleSide })] }));
});
function createPolygonsFromGeometry(vertices, indices) {
    const polygons = [];
    for (let i = 0; i < indices.length; i += 3) {
        const i0 = indices[i] * 3;
        const i1 = indices[i + 1] * 3;
        const i2 = indices[i + 2] * 3;
        const v0 = new YUKA.Vector3(vertices[i0], vertices[i0 + 1], vertices[i0 + 2]);
        const v1 = new YUKA.Vector3(vertices[i1], vertices[i1 + 1], vertices[i1 + 2]);
        const v2 = new YUKA.Vector3(vertices[i2], vertices[i2 + 1], vertices[i2 + 2]);
        const polygon = new YUKA.Polygon();
        polygon.fromContour([v0, v1, v2]);
        polygons.push(polygon);
    }
    return polygons;
}
export { yukaVector3ToThree, threeVector3ToYuka, syncYukaToThree };
//# sourceMappingURL=AI.js.map