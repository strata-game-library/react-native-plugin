import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
/**
 * Volumetric Effects Component
 *
 * Provides raymarched volumetric fog, underwater effects, and atmospheric scattering
 * using shader-based post-processing.
 *
 * Lifted from Otterfall procedural rendering system.
 */
import { useFrame, useThree } from '@react-three/fiber';
import { useEffect, useMemo, useRef } from 'react';
import * as THREE from 'three';
import { createUnderwaterOverlayMaterial, createVolumetricFogMeshMaterial, } from '../core/volumetrics';
/**
 * Simple fog implementation using Three.js built-in fog with enhanced visuals
 */
export function EnhancedFog({ color = 0xb3c8d9, density = 0.02, near, far }) {
    const { scene } = useThree();
    useEffect(() => {
        const fogColor = new THREE.Color(color);
        if (near !== undefined && far !== undefined) {
            scene.fog = new THREE.Fog(fogColor, near, far);
        }
        else {
            scene.fog = new THREE.FogExp2(fogColor.getHex(), density);
        }
        return () => {
            scene.fog = null;
        };
    }, [scene, color, density, near, far]);
    return null;
}
export function UnderwaterOverlay({ color = 0x004d66, density = 0.1, causticStrength = 0.3, waterSurface = 0, }) {
    const { camera } = useThree();
    const overlayRef = useRef(null);
    const material = useMemo(() => {
        return createUnderwaterOverlayMaterial({
            waterColor: new THREE.Color(color),
            density,
            causticStrength,
            waterSurface,
        });
    }, [color, density, causticStrength, waterSurface]);
    useFrame((state) => {
        if (material?.uniforms) {
            material.uniforms.uTime.value = state.clock.elapsedTime;
            material.uniforms.uCameraY.value = camera.position.y;
        }
    });
    useEffect(() => {
        return () => {
            material.dispose();
        };
    }, [material]);
    return (_jsxs("mesh", { ref: overlayRef, renderOrder: 999, children: [_jsx("planeGeometry", { args: [2, 2] }), _jsx("primitive", { object: material, attach: "material" })] }));
}
export function VolumetricFogMesh({ color = 0xb3c8d9, density = 0.02, height = 10, size = 200, }) {
    const meshRef = useRef(null);
    const { camera } = useThree();
    const fogColor = useMemo(() => new THREE.Color(color), [color]);
    const material = useMemo(() => {
        return createVolumetricFogMeshMaterial({
            color: fogColor,
            density,
            height,
            cameraPosition: camera.position,
        });
    }, [fogColor, density, height, camera]);
    useFrame((state) => {
        if (material?.uniforms && meshRef.current) {
            material.uniforms.uTime.value = state.clock.elapsedTime;
            material.uniforms.uCameraPosition.value = camera.position.toArray();
            meshRef.current.position.set(camera.position.x, 0, camera.position.z);
        }
    });
    useEffect(() => {
        return () => {
            material.dispose();
        };
    }, [material]);
    return (_jsxs("mesh", { ref: meshRef, position: [0, height / 2, 0], children: [_jsx("boxGeometry", { args: [size, height, size, 1, 8, 1] }), _jsx("primitive", { object: material, attach: "material" })] }));
}
export function VolumetricEffects({ enableFog = true, enableUnderwater = true, fogSettings = {}, underwaterSettings = {}, }) {
    return (_jsxs(_Fragment, { children: [enableFog && (_jsx(VolumetricFogMesh, { color: fogSettings.color, density: fogSettings.density, height: fogSettings.height })), enableUnderwater && (_jsx(UnderwaterOverlay, { color: underwaterSettings.color, density: underwaterSettings.density, causticStrength: underwaterSettings.causticStrength, waterSurface: underwaterSettings.waterSurface }))] }));
}
//# sourceMappingURL=VolumetricEffects.js.map