import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
/**
 * Animation components for Strata
 *
 * React Three Fiber components for procedural animation including
 * IK chains, spring dynamics, look-at controllers, and locomotion.
 * @module components/Animation
 */
import { useFrame, useThree } from '@react-three/fiber';
import { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useRef } from 'react';
import * as THREE from 'three';
import { CCDSolver, createBoneChainFromLengths, FABRIKSolver, LookAtController, ProceduralGait, SpringChain, SpringDynamics, TwoBoneIKSolver, } from '../core/animation';
export const IKChain = forwardRef(({ boneLengths, target, pole, solver = 'fabrik', tolerance = 0.001, maxIterations = 20, visualize = false, visualColor = '#00ff00', visualRadius = 0.05, children, onSolve, }, ref) => {
    const groupRef = useRef(null);
    const chainRef = useRef(null);
    const resultRef = useRef(null);
    const solverInstance = useMemo(() => {
        return solver === 'fabrik'
            ? new FABRIKSolver(tolerance, maxIterations)
            : new CCDSolver(tolerance, maxIterations);
    }, [solver, tolerance, maxIterations]);
    useEffect(() => {
        if (groupRef.current && boneLengths.length > 0) {
            groupRef.current.children.forEach((child) => {
                if (child.type === 'Object3D') {
                    groupRef.current?.remove(child);
                }
            });
            chainRef.current = createBoneChainFromLengths(groupRef.current, boneLengths, new THREE.Vector3(0, -1, 0));
        }
    }, [boneLengths]);
    const getTargetPosition = useCallback(() => {
        if (target instanceof THREE.Vector3)
            return target;
        if (target.current) {
            const pos = new THREE.Vector3();
            target.current.getWorldPosition(pos);
            return pos;
        }
        return new THREE.Vector3();
    }, [target]);
    const getPolePosition = useCallback(() => {
        if (!pole)
            return undefined;
        if (pole instanceof THREE.Vector3)
            return pole;
        if (pole.current) {
            const pos = new THREE.Vector3();
            pole.current.getWorldPosition(pos);
            return pos;
        }
        return undefined;
    }, [pole]);
    const solve = useCallback(() => {
        if (!chainRef.current)
            return;
        const targetPos = getTargetPosition();
        const polePos = getPolePosition();
        const result = solver === 'fabrik'
            ? solverInstance.solve(chainRef.current, targetPos, polePos)
            : solverInstance.solve(chainRef.current, targetPos);
        resultRef.current = result;
        if (solver === 'fabrik') {
            solverInstance.apply(chainRef.current, result);
        }
        else {
            solverInstance.apply(chainRef.current, result);
        }
        onSolve?.(result);
    }, [solver, solverInstance, getTargetPosition, getPolePosition, onSolve]);
    useImperativeHandle(ref, () => ({
        getBones: () => chainRef.current?.bones ?? [],
        getResult: () => resultRef.current,
        solve,
    }));
    useFrame(() => {
        solve();
    });
    const visualBones = useMemo(() => {
        if (!visualize)
            return null;
        return boneLengths.map((length, i) => (_jsxs("group", { children: [_jsxs("mesh", { position: [0, -length / 2, 0], children: [_jsx("cylinderGeometry", { args: [visualRadius, visualRadius * 0.8, length, 8] }), _jsx("meshStandardMaterial", { color: visualColor })] }), _jsxs("mesh", { children: [_jsx("sphereGeometry", { args: [visualRadius * 1.2, 8, 8] }), _jsx("meshStandardMaterial", { color: visualColor })] })] }, i)));
    }, [visualize, boneLengths, visualColor, visualRadius]);
    return (_jsxs("group", { ref: groupRef, children: [visualBones, children] }));
});
IKChain.displayName = 'IKChain';
export const IKLimb = forwardRef(({ upperLength, lowerLength, target, poleTarget, visualize = false, visualColor = '#4488ff', children, onSolve, }, ref) => {
    const groupRef = useRef(null);
    const upperRef = useRef(null);
    const lowerRef = useRef(null);
    const endRef = useRef(null);
    const solver = useMemo(() => new TwoBoneIKSolver(), []);
    useImperativeHandle(ref, () => ({
        getUpperBone: () => upperRef.current,
        getLowerBone: () => lowerRef.current,
        getEndEffector: () => endRef.current,
    }));
    const getTargetPosition = useCallback(() => {
        if (target instanceof THREE.Vector3)
            return target;
        if (target.current) {
            const pos = new THREE.Vector3();
            target.current.getWorldPosition(pos);
            return pos;
        }
        return new THREE.Vector3();
    }, [target]);
    const getPolePosition = useCallback(() => {
        if (poleTarget instanceof THREE.Vector3)
            return poleTarget;
        if (poleTarget.current) {
            const pos = new THREE.Vector3();
            poleTarget.current.getWorldPosition(pos);
            return pos;
        }
        return new THREE.Vector3(0, 0, 1);
    }, [poleTarget]);
    useFrame(() => {
        if (!groupRef.current || !upperRef.current || !lowerRef.current || !endRef.current)
            return;
        const rootPos = new THREE.Vector3();
        const midPos = new THREE.Vector3();
        const endPos = new THREE.Vector3();
        groupRef.current.getWorldPosition(rootPos);
        lowerRef.current.getWorldPosition(midPos);
        endRef.current.getWorldPosition(endPos);
        const targetPos = getTargetPosition();
        const polePos = getPolePosition();
        solver.solveLimb(upperRef.current, lowerRef.current, endRef.current, targetPos, polePos);
        lowerRef.current.getWorldPosition(midPos);
        endRef.current.getWorldPosition(endPos);
        onSolve?.(midPos, endPos);
    });
    return (_jsxs("group", { ref: groupRef, children: [_jsxs("object3D", { ref: upperRef, children: [visualize && (_jsxs("mesh", { position: [0, -upperLength / 2, 0], children: [_jsx("cylinderGeometry", { args: [0.05, 0.04, upperLength, 8] }), _jsx("meshStandardMaterial", { color: visualColor })] })), _jsxs("object3D", { ref: lowerRef, position: [0, -upperLength, 0], children: [visualize && (_jsxs("mesh", { position: [0, -lowerLength / 2, 0], children: [_jsx("cylinderGeometry", { args: [0.04, 0.03, lowerLength, 8] }), _jsx("meshStandardMaterial", { color: visualColor })] })), _jsx("object3D", { ref: endRef, position: [0, -lowerLength, 0] })] })] }), children] }));
});
IKLimb.displayName = 'IKLimb';
export const LookAt = forwardRef(({ target, config, children }, ref) => {
    const groupRef = useRef(null);
    const controller = useMemo(() => new LookAtController(config), [config]);
    useImperativeHandle(ref, () => ({
        getRotation: () => controller.update(groupRef.current, new THREE.Vector3(), 0),
        reset: () => controller.reset(),
    }));
    const getTargetPosition = useCallback(() => {
        if (target instanceof THREE.Vector3)
            return target;
        if (target.current) {
            const pos = new THREE.Vector3();
            target.current.getWorldPosition(pos);
            return pos;
        }
        return new THREE.Vector3(0, 0, 1);
    }, [target]);
    useFrame((_, delta) => {
        if (!groupRef.current)
            return;
        const targetPos = getTargetPosition();
        const rotation = controller.update(groupRef.current, targetPos, delta);
        groupRef.current.quaternion.copy(rotation);
    });
    return _jsx("group", { ref: groupRef, children: children });
});
LookAt.displayName = 'LookAt';
export const SpringBone = forwardRef(({ config, gravity = [0, -9.8, 0], children }, ref) => {
    const groupRef = useRef(null);
    const _parentRef = useRef(new THREE.Vector3());
    const spring = useMemo(() => new SpringDynamics(config), [config]);
    const gravityVec = useMemo(() => new THREE.Vector3(...gravity), [gravity]);
    useImperativeHandle(ref, () => ({
        getPosition: () => spring.getPosition(),
        getVelocity: () => spring.getVelocity(),
        reset: () => spring.reset(),
    }));
    useFrame((_, delta) => {
        if (!groupRef.current || !groupRef.current.parent)
            return;
        const parentWorldPos = new THREE.Vector3();
        groupRef.current.parent.getWorldPosition(parentWorldPos);
        const target = parentWorldPos.clone().add(gravityVec.clone().multiplyScalar(0.1));
        const newPos = spring.update(target, delta);
        const localPos = newPos.clone();
        if (groupRef.current.parent) {
            groupRef.current.parent.worldToLocal(localPos);
        }
        groupRef.current.position.copy(localPos);
    });
    return _jsx("group", { ref: groupRef, children: children });
});
SpringBone.displayName = 'SpringBone';
export const ProceduralWalk = forwardRef(({ config, bodyRef, leftFootRef, rightFootRef, enabled = true, onStep }, ref) => {
    const gaitRef = useRef(null);
    const stateRef = useRef(null);
    const lastPositionRef = useRef(new THREE.Vector3());
    const velocityRef = useRef(new THREE.Vector3());
    const wasLeftLifted = useRef(false);
    const wasRightLifted = useRef(false);
    useEffect(() => {
        gaitRef.current = new ProceduralGait(config);
    }, [config]);
    useImperativeHandle(ref, () => ({
        getState: () => stateRef.current,
        getPhase: () => gaitRef.current?.getPhase() ?? 0,
        reset: () => gaitRef.current?.reset(),
    }));
    useFrame((_, delta) => {
        if (!enabled || !gaitRef.current || !bodyRef.current)
            return;
        const bodyPos = new THREE.Vector3();
        bodyRef.current.getWorldPosition(bodyPos);
        velocityRef.current
            .copy(bodyPos)
            .sub(lastPositionRef.current)
            .divideScalar(Math.max(delta, 0.001));
        lastPositionRef.current.copy(bodyPos);
        const forward = new THREE.Vector3(0, 0, 1);
        bodyRef.current.getWorldDirection(forward);
        const state = gaitRef.current.update(bodyPos, forward, velocityRef.current, delta);
        stateRef.current = state;
        if (leftFootRef?.current) {
            leftFootRef.current.position.copy(state.leftFootTarget);
        }
        if (rightFootRef?.current) {
            rightFootRef.current.position.copy(state.rightFootTarget);
        }
        if (!wasLeftLifted.current && state.leftFootLifted) {
            onStep?.('left', state.leftFootTarget);
        }
        if (!wasRightLifted.current && state.rightFootLifted) {
            onStep?.('right', state.rightFootTarget);
        }
        wasLeftLifted.current = state.leftFootLifted;
        wasRightLifted.current = state.rightFootLifted;
    });
    return null;
});
ProceduralWalk.displayName = 'ProceduralWalk';
export const HeadTracker = forwardRef(({ target, followMouse = false, maxAngle = Math.PI / 3, speed = 5, deadzone = 0.01, children, }, ref) => {
    const groupRef = useRef(null);
    const mouseTarget = useRef(new THREE.Vector3());
    const { camera, size } = useThree();
    const controller = useMemo(() => new LookAtController({
        maxAngle,
        speed,
        deadzone,
    }), [maxAngle, speed, deadzone]);
    useImperativeHandle(ref, () => ({
        lookAt: (pos) => {
            mouseTarget.current.copy(pos);
        },
        reset: () => controller.reset(),
    }));
    useEffect(() => {
        if (!followMouse)
            return;
        const handleMouseMove = (event) => {
            const x = (event.clientX / size.width) * 2 - 1;
            const y = -(event.clientY / size.height) * 2 + 1;
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -5);
            raycaster.ray.intersectPlane(plane, mouseTarget.current);
        };
        window.addEventListener('mousemove', handleMouseMove);
        return () => window.removeEventListener('mousemove', handleMouseMove);
    }, [followMouse, camera, size]);
    const getTargetPosition = useCallback(() => {
        if (followMouse)
            return mouseTarget.current;
        if (target instanceof THREE.Vector3)
            return target;
        if (target?.current) {
            const pos = new THREE.Vector3();
            target.current.getWorldPosition(pos);
            return pos;
        }
        return new THREE.Vector3(0, 0, 5);
    }, [target, followMouse]);
    useFrame((_, delta) => {
        if (!groupRef.current)
            return;
        const targetPos = getTargetPosition();
        const rotation = controller.update(groupRef.current, targetPos, delta);
        groupRef.current.quaternion.copy(rotation);
    });
    return _jsx("group", { ref: groupRef, children: children });
});
HeadTracker.displayName = 'HeadTracker';
export const TailPhysics = forwardRef(({ segmentCount, segmentLength = 0.3, config, gravity = [0, -9.8, 0], visualize = false, visualColor = '#ff8844', visualRadius = 0.03, children, }, ref) => {
    const groupRef = useRef(null);
    const segmentsRef = useRef([]);
    const positionsRef = useRef([]);
    const chain = useMemo(() => new SpringChain(segmentCount, config, segmentLength), [segmentCount, config, segmentLength]);
    const gravityVec = useMemo(() => new THREE.Vector3(...gravity), [gravity]);
    useImperativeHandle(ref, () => ({
        getPositions: () => positionsRef.current,
        reset: () => {
            const positions = segmentsRef.current.map((_, i) => new THREE.Vector3(0, -segmentLength * (i + 1), 0));
            chain.reset(positions);
        },
    }));
    useFrame((_, delta) => {
        if (!groupRef.current)
            return;
        const rootPos = new THREE.Vector3();
        const rootQuat = new THREE.Quaternion();
        groupRef.current.getWorldPosition(rootPos);
        groupRef.current.getWorldQuaternion(rootQuat);
        const positions = chain.update(rootPos, rootQuat, delta, gravityVec);
        positionsRef.current = positions;
        for (let i = 0; i < segmentsRef.current.length && i < positions.length - 1; i++) {
            const segment = segmentsRef.current[i];
            if (!segment)
                continue;
            const currentPos = positions[i];
            const nextPos = positions[i + 1];
            const localPos = nextPos.clone();
            if (groupRef.current) {
                groupRef.current.worldToLocal(localPos);
            }
            segment.position.copy(localPos);
            const direction = nextPos.clone().sub(currentPos).normalize();
            const up = new THREE.Vector3(0, 1, 0);
            const quaternion = new THREE.Quaternion();
            const matrix = new THREE.Matrix4().lookAt(new THREE.Vector3(), direction, up);
            quaternion.setFromRotationMatrix(matrix);
            segment.quaternion.copy(quaternion);
        }
    });
    const segments = useMemo(() => {
        return Array.from({ length: segmentCount }, (_, i) => (_jsx("object3D", { ref: (el) => {
                if (el)
                    segmentsRef.current[i] = el;
            }, position: [0, -segmentLength * (i + 1), 0], children: visualize && (_jsxs(_Fragment, { children: [_jsxs("mesh", { children: [_jsx("sphereGeometry", { args: [visualRadius * (1 - (i / segmentCount) * 0.5), 8, 8] }), _jsx("meshStandardMaterial", { color: visualColor })] }), i < segmentCount - 1 && (_jsxs("mesh", { position: [0, -segmentLength / 2, 0], children: [_jsx("cylinderGeometry", { args: [
                                    visualRadius * 0.5,
                                    visualRadius * 0.5,
                                    segmentLength,
                                    6,
                                ] }), _jsx("meshStandardMaterial", { color: visualColor })] }))] })) }, i)));
    }, [segmentCount, segmentLength, visualize, visualColor, visualRadius]);
    return (_jsxs("group", { ref: groupRef, children: [segments, children] }));
});
TailPhysics.displayName = 'TailPhysics';
export const BreathingAnimation = forwardRef(({ amplitude = 0.02, frequency = 1, axis = 'y', children }, ref) => {
    const groupRef = useRef(null);
    const pausedRef = useRef(false);
    const amplitudeRef = useRef(amplitude);
    const timeRef = useRef(0);
    useEffect(() => {
        amplitudeRef.current = amplitude;
    }, [amplitude]);
    useImperativeHandle(ref, () => ({
        pause: () => {
            pausedRef.current = true;
        },
        resume: () => {
            pausedRef.current = false;
        },
        setAmplitude: (a) => {
            amplitudeRef.current = a;
        },
    }));
    useFrame((_, delta) => {
        if (!groupRef.current || pausedRef.current)
            return;
        timeRef.current += delta;
        const value = Math.sin(timeRef.current * frequency * Math.PI * 2) * amplitudeRef.current;
        if (axis === 'scale') {
            const scale = 1 + value;
            groupRef.current.scale.set(scale, scale, scale);
        }
        else {
            groupRef.current.position[axis] = value;
        }
    });
    return _jsx("group", { ref: groupRef, children: children });
});
BreathingAnimation.displayName = 'BreathingAnimation';
export const BlinkController = forwardRef(({ blinkDuration = 0.15, minInterval = 2, maxInterval = 6, leftEyeRef, rightEyeRef, onBlink, children, }, ref) => {
    const groupRef = useRef(null);
    const blinkingRef = useRef(true);
    const nextBlinkRef = useRef(0);
    const blinkProgressRef = useRef(1);
    const baseScaleRef = useRef(null);
    const scheduleNextBlink = useCallback(() => {
        nextBlinkRef.current = minInterval + Math.random() * (maxInterval - minInterval);
    }, [minInterval, maxInterval]);
    useEffect(() => {
        scheduleNextBlink();
    }, [scheduleNextBlink]);
    const triggerBlink = useCallback(() => {
        blinkProgressRef.current = 0;
        onBlink?.();
    }, [onBlink]);
    useImperativeHandle(ref, () => ({
        blink: triggerBlink,
        setBlinking: (enabled) => {
            blinkingRef.current = enabled;
        },
    }));
    useFrame((_, delta) => {
        if (!baseScaleRef.current && leftEyeRef?.current && rightEyeRef?.current) {
            baseScaleRef.current = {
                left: leftEyeRef.current.scale.clone(),
                right: rightEyeRef.current.scale.clone(),
            };
        }
        if (blinkProgressRef.current < 1) {
            blinkProgressRef.current = Math.min(1, blinkProgressRef.current + delta / blinkDuration);
            const t = blinkProgressRef.current;
            // Use proper blink animation: closing phase (0-0.5), opening phase (0.5-1)
            const blinkValue = 1 - Math.sin(t * Math.PI);
            const scaleY = Math.max(0.1, blinkValue);
            if (leftEyeRef?.current && baseScaleRef.current) {
                leftEyeRef.current.scale.y = baseScaleRef.current.left.y * scaleY;
            }
            if (rightEyeRef?.current && baseScaleRef.current) {
                rightEyeRef.current.scale.y = baseScaleRef.current.right.y * scaleY;
            }
        }
        else if (blinkingRef.current) {
            nextBlinkRef.current -= delta;
            if (nextBlinkRef.current <= 0) {
                triggerBlink();
                scheduleNextBlink();
            }
        }
    });
    return _jsx("group", { ref: groupRef, children: children });
});
BlinkController.displayName = 'BlinkController';
//# sourceMappingURL=Animation.js.map