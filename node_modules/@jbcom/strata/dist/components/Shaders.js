import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
/**
 * React components for shader materials
 * Provides easy-to-use components for common shader effects
 */
import { useFrame } from '@react-three/fiber';
import React, { forwardRef, useImperativeHandle, useMemo, useRef } from 'react';
import { createCrystalMaterial, createDissolveMaterial, createForcefieldMaterial, createGlitchMaterial, createGradientMaterial, createHologramMaterial, createOutlineMaterial, createToonMaterial, } from '../shaders/materials';
export const ToonMesh = forwardRef(({ geometry, children, position = [0, 0, 0], rotation = [0, 0, 0], scale = 1, showOutline = true, ...materialOptions }, ref) => {
    const meshRef = useRef(null);
    const outlineRef = useRef(null);
    const material = useMemo(() => createToonMaterial(materialOptions), [
        materialOptions.color,
        materialOptions.levels,
        materialOptions.rimColor,
        materialOptions.rimPower,
        materialOptions,
    ]);
    const outlineMaterial = useMemo(() => createOutlineMaterial({
        color: materialOptions.outlineColor || 0x000000,
        outlineWidth: materialOptions.outlineWidth || 0.03,
    }), [materialOptions.outlineColor, materialOptions.outlineWidth]);
    useImperativeHandle(ref, () => ({
        mesh: meshRef.current,
        material,
    }));
    const scaleArray = typeof scale === 'number' ? [scale, scale, scale] : scale;
    return (_jsxs("group", { position: position, rotation: rotation, scale: scaleArray, children: [_jsxs("mesh", { ref: meshRef, geometry: geometry, children: [children, _jsx("primitive", { object: material, attach: "material" })] }), showOutline && (_jsxs("mesh", { ref: outlineRef, geometry: geometry || meshRef.current?.geometry, children: [children, _jsx("primitive", { object: outlineMaterial, attach: "material" })] }))] }));
});
ToonMesh.displayName = 'ToonMesh';
export const HologramMesh = forwardRef(({ geometry, children, position = [0, 0, 0], rotation = [0, 0, 0], scale = 1, animate = true, ...materialOptions }, ref) => {
    const meshRef = useRef(null);
    const material = useMemo(() => createHologramMaterial(materialOptions), [
        materialOptions.color,
        materialOptions.scanlineIntensity,
        materialOptions.scanlineDensity,
        materialOptions.flickerSpeed,
        materialOptions.fresnelPower,
        materialOptions.alpha,
        materialOptions,
    ]);
    useFrame((state) => {
        if (animate && material.uniforms.uTime) {
            material.uniforms.uTime.value = state.clock.elapsedTime;
        }
    });
    useImperativeHandle(ref, () => ({
        mesh: meshRef.current,
        material,
    }));
    const scaleArray = typeof scale === 'number' ? [scale, scale, scale] : scale;
    return (_jsxs("mesh", { ref: meshRef, geometry: geometry, position: position, rotation: rotation, scale: scaleArray, children: [children, _jsx("primitive", { object: material, attach: "material" })] }));
});
HologramMesh.displayName = 'HologramMesh';
export const DissolveMesh = forwardRef(({ geometry, children, position = [0, 0, 0], rotation = [0, 0, 0], scale = 1, animate = false, animationSpeed = 0.5, loop = false, ...materialOptions }, ref) => {
    const meshRef = useRef(null);
    const material = useMemo(() => createDissolveMaterial(materialOptions), [
        materialOptions.color,
        materialOptions.edgeColor,
        materialOptions.progress,
        materialOptions.edgeWidth,
        materialOptions.noiseScale,
        materialOptions,
    ]);
    useFrame((state, delta) => {
        if (material.uniforms.uTime) {
            material.uniforms.uTime.value = state.clock.elapsedTime;
        }
        if (animate && material.uniforms.uProgress) {
            let progress = material.uniforms.uProgress.value + delta * animationSpeed;
            if (loop) {
                progress = progress % 1;
            }
            else {
                progress = Math.min(progress, 1);
            }
            material.uniforms.uProgress.value = progress;
        }
    });
    useImperativeHandle(ref, () => ({
        mesh: meshRef.current,
        material,
        setProgress: (progress) => {
            if (material.uniforms.uProgress) {
                material.uniforms.uProgress.value = Math.max(0, Math.min(1, progress));
            }
        },
    }));
    const scaleArray = typeof scale === 'number' ? [scale, scale, scale] : scale;
    return (_jsxs("mesh", { ref: meshRef, geometry: geometry, position: position, rotation: rotation, scale: scaleArray, children: [children, _jsx("primitive", { object: material, attach: "material" })] }));
});
DissolveMesh.displayName = 'DissolveMesh';
export const Forcefield = forwardRef(({ radius = 1, position = [0, 0, 0], animate = true, ...materialOptions }, ref) => {
    const meshRef = useRef(null);
    const hitDecay = useRef(0);
    const material = useMemo(() => createForcefieldMaterial(materialOptions), [
        materialOptions.color,
        materialOptions.secondaryColor,
        materialOptions.fresnelPower,
        materialOptions.pulseSpeed,
        materialOptions.hexagonScale,
        materialOptions.alpha,
        materialOptions,
    ]);
    useFrame((state, delta) => {
        if (animate && material.uniforms.uTime) {
            material.uniforms.uTime.value = state.clock.elapsedTime;
        }
        if (hitDecay.current > 0) {
            hitDecay.current -= delta * 3;
            material.uniforms.uHitIntensity.value = Math.max(0, hitDecay.current);
        }
    });
    const triggerHit = (worldPosition, intensity = 1) => {
        if (meshRef.current) {
            const localPos = meshRef.current.worldToLocal(worldPosition.clone());
            material.uniforms.uHitPoint.value.copy(localPos);
            material.uniforms.uHitIntensity.value = intensity;
            hitDecay.current = intensity;
        }
    };
    useImperativeHandle(ref, () => ({
        mesh: meshRef.current,
        material,
        triggerHit,
    }));
    return (_jsxs("mesh", { ref: meshRef, position: position, children: [_jsx("sphereGeometry", { args: [radius, 64, 64] }), _jsx("primitive", { object: material, attach: "material" })] }));
});
Forcefield.displayName = 'Forcefield';
export const Outline = ({ children, ...materialOptions }) => {
    const groupRef = useRef(null);
    const outlineMaterial = useMemo(() => createOutlineMaterial(materialOptions), [materialOptions.color, materialOptions.outlineWidth, materialOptions]);
    return (_jsx("group", { ref: groupRef, children: React.Children.map(children, (child) => {
            if (React.isValidElement(child) && child.type === 'mesh') {
                return (_jsxs(_Fragment, { children: [child, React.cloneElement(child, {
                            children: (_jsxs(_Fragment, { children: [child.props.children, _jsx("primitive", { object: outlineMaterial.clone(), attach: "material" })] })),
                        })] }));
            }
            return child;
        }) }));
};
export const GradientMesh = forwardRef(({ geometry, children, position = [0, 0, 0], rotation = [0, 0, 0], scale = 1, ...materialOptions }, ref) => {
    const meshRef = useRef(null);
    const material = useMemo(() => createGradientMaterial(materialOptions), [
        materialOptions.colorStart,
        materialOptions.colorEnd,
        materialOptions.colorMiddle,
        materialOptions.direction,
        materialOptions.useThreeColors,
        materialOptions,
    ]);
    useImperativeHandle(ref, () => ({
        mesh: meshRef.current,
        material,
    }));
    const scaleArray = typeof scale === 'number' ? [scale, scale, scale] : scale;
    return (_jsxs("mesh", { ref: meshRef, geometry: geometry, position: position, rotation: rotation, scale: scaleArray, children: [children, _jsx("primitive", { object: material, attach: "material" })] }));
});
GradientMesh.displayName = 'GradientMesh';
export const GlitchMesh = forwardRef(({ geometry, children, position = [0, 0, 0], rotation = [0, 0, 0], scale = 1, animate = true, ...materialOptions }, ref) => {
    const meshRef = useRef(null);
    const material = useMemo(() => createGlitchMaterial(materialOptions), [
        materialOptions.color,
        materialOptions.glitchIntensity,
        materialOptions.scanlineIntensity,
        materialOptions.rgbShiftAmount,
        materialOptions,
    ]);
    useFrame((state) => {
        if (animate && material.uniforms.uTime) {
            material.uniforms.uTime.value = state.clock.elapsedTime;
        }
    });
    useImperativeHandle(ref, () => ({
        mesh: meshRef.current,
        material,
    }));
    const scaleArray = typeof scale === 'number' ? [scale, scale, scale] : scale;
    return (_jsxs("mesh", { ref: meshRef, geometry: geometry, position: position, rotation: rotation, scale: scaleArray, children: [children, _jsx("primitive", { object: material, attach: "material" })] }));
});
GlitchMesh.displayName = 'GlitchMesh';
export const CrystalMesh = forwardRef(({ geometry, children, position = [0, 0, 0], rotation = [0, 0, 0], scale = 1, animate = true, ...materialOptions }, ref) => {
    const meshRef = useRef(null);
    const material = useMemo(() => createCrystalMaterial(materialOptions), [
        materialOptions.color,
        materialOptions.fresnelPower,
        materialOptions.rainbowIntensity,
        materialOptions,
    ]);
    useFrame((state) => {
        if (animate && material.uniforms.uTime) {
            material.uniforms.uTime.value = state.clock.elapsedTime;
        }
    });
    useImperativeHandle(ref, () => ({
        mesh: meshRef.current,
        material,
    }));
    const scaleArray = typeof scale === 'number' ? [scale, scale, scale] : scale;
    return (_jsxs("mesh", { ref: meshRef, geometry: geometry, position: position, rotation: rotation, scale: scaleArray, children: [children, _jsx("primitive", { object: material, attach: "material" })] }));
});
CrystalMesh.displayName = 'CrystalMesh';
//# sourceMappingURL=Shaders.js.map