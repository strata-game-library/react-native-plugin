import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 * Procedural Water components
 *
 * Lifted from Otterfall procedural rendering system.
 */
import { useFrame } from '@react-three/fiber';
import { forwardRef, useEffect, useMemo, useRef } from 'react';
import * as THREE from 'three';
import { createAdvancedWaterMaterial, createWaterMaterial } from '../core/water';
/**
 * Simple procedural water surface with wave animation
 */
export const Water = forwardRef(({ position = [0, -0.2, 0], size = 100, segments = 32, color = 0x006994, opacity = 0.8, waveSpeed = 1.0, waveHeight = 0.5, }, ref) => {
    const internalRef = useRef(null);
    const meshRef = ref || internalRef;
    const material = useMemo(() => {
        const mat = createWaterMaterial();
        if (mat.uniforms) {
            mat.uniforms.waterColor = { value: new THREE.Color(color) };
            mat.uniforms.opacity = { value: opacity };
            mat.uniforms.waveSpeed = { value: waveSpeed };
            mat.uniforms.waveHeight = { value: waveHeight };
        }
        mat.transparent = opacity < 1;
        mat.opacity = opacity;
        return mat;
    }, [color, opacity, waveSpeed, waveHeight]);
    useEffect(() => {
        return () => {
            material.dispose();
        };
    }, [material]);
    useFrame((_, delta) => {
        if (material.uniforms?.time) {
            material.uniforms.time.value += delta * waveSpeed;
        }
    });
    return (_jsxs("mesh", { ref: meshRef, position: position, rotation: [-Math.PI / 2, 0, 0], renderOrder: -1, children: [_jsx("planeGeometry", { args: [size, size, segments, segments] }), _jsx("primitive", { object: material, attach: "material" })] }));
});
Water.displayName = 'Water';
/**
 * Advanced water with caustics and foam effects
 */
export const AdvancedWater = forwardRef(({ position = [0, 0, 0], size = 100, segments = 64, color = 0x2a5a8a, deepColor = 0x1a3a5a, foamColor = 0x8ab4d4, causticIntensity = 0.4, waveHeight = 0.5, waveSpeed = 1.0, }, ref) => {
    const internalRef = useRef(null);
    const waterRef = ref || internalRef;
    const resolvedSize = Array.isArray(size) ? size : [size, size];
    useFrame((state) => {
        const mesh = waterRef.current;
        if (mesh) {
            const mat = mesh.material;
            if (mat.uniforms?.uTime) {
                mat.uniforms.uTime.value = state.clock.getElapsedTime() * waveSpeed;
            }
            // Apply waveHeight to material uniform if available
            if (mat.uniforms?.uWaveHeight) {
                mat.uniforms.uWaveHeight.value = waveHeight;
            }
        }
    });
    const waterMaterial = useMemo(() => createAdvancedWaterMaterial({
        waterColor: color,
        deepWaterColor: deepColor,
        foamColor: foamColor,
        causticIntensity,
    }), [color, deepColor, foamColor, causticIntensity]);
    const waterGeometry = useMemo(() => new THREE.PlaneGeometry(resolvedSize[0], resolvedSize[1], segments, segments), [resolvedSize, segments]);
    useEffect(() => {
        return () => {
            waterGeometry.dispose();
            waterMaterial.dispose();
        };
    }, [waterGeometry, waterMaterial]);
    return (_jsxs("mesh", { ref: waterRef, position: position, rotation: [-Math.PI / 2, 0, 0], receiveShadow: true, children: [_jsx("primitive", { object: waterGeometry }), _jsx("primitive", { object: waterMaterial })] }));
});
AdvancedWater.displayName = 'AdvancedWater';
//# sourceMappingURL=Water.js.map