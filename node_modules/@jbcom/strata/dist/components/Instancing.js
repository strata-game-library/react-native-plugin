import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 * GPU-Driven Instancing System
 *
 * Uses drei's Instances component for true GPU-driven instancing
 * with wind animation and LOD calculations performed on the GPU.
 *
 * Optimized for mobile, web, and desktop with support for thousands
 * of instances with minimal CPU overhead.
 *
 * Lifted from Otterfall procedural rendering system.
 */
import { Instance, Instances } from '@react-three/drei';
import { useThree } from '@react-three/fiber';
import { useEffect, useMemo, useRef } from 'react';
import * as THREE from 'three';
import { generateInstanceData as coreGenerateInstanceData, } from '../core/instancing';
import { getBiomeAt as sdfGetBiomeAt } from '../core/sdf';
// =============================================================================
// INSTANCE GENERATION
// =============================================================================
// Core logic moved to core/instancing.ts
// Re-export core function with proper name
export function generateInstanceData(count, areaSize, heightFunc, biomes, allowedBiomes, seed) {
    return coreGenerateInstanceData(count, areaSize, heightFunc, biomes, allowedBiomes, seed, getBiomeAt, noise3D, fbm);
}
// Import noise functions from core for use in component
import { fbm, getBiomeAt, noise3D } from '../core/sdf';
export function GPUInstancedMesh({ geometry, material, count, instances, enableWind = true, windStrength = 0.5, lodDistance = 100, frustumCulled = true, castShadow = true, receiveShadow = true, }) {
    const _meshRef = useRef(null);
    const _camera = useThree().camera;
    // Input validation
    if (!geometry) {
        throw new Error('GPUInstancedMesh: geometry is required');
    }
    if (!material) {
        throw new Error('GPUInstancedMesh: material is required');
    }
    if (count <= 0) {
        throw new Error('GPUInstancedMesh: count must be positive');
    }
    if (!instances || instances.length === 0) {
        throw new Error('GPUInstancedMesh: instances array cannot be empty');
    }
    // Use drei's Instances component for GPU-optimized instancing
    // NOTE: Wind and LOD are not yet implemented on GPU - these props are reserved for future implementation
    // Current implementation uses drei's Instances which provides efficient GPU instancing
    // but wind/LOD would require custom vertex shader integration
    // Reserved for future use: enableWind, windStrength, lodDistance, _meshRef, _camera
    const instanceCount = Math.min(instances.length, count);
    return (_jsxs(Instances, { limit: instanceCount, range: instanceCount, frustumCulled: frustumCulled, castShadow: castShadow, receiveShadow: receiveShadow, children: [_jsx("primitive", { object: geometry, attach: "geometry" }), _jsx("primitive", { object: material, attach: "material" }), instances.slice(0, instanceCount).map((instance, i) => (_jsx(Instance, { position: instance.position, rotation: [instance.rotation.x, instance.rotation.y, instance.rotation.z], scale: instance.scale }, i)))] }));
}
const DEFAULT_BIOMES = [
    { type: 'marsh', center: new THREE.Vector2(0, 0), radius: 30 },
    { type: 'forest', center: new THREE.Vector2(50, 0), radius: 40 },
    { type: 'savanna', center: new THREE.Vector2(60, 60), radius: 50 },
];
/**
 * Instanced grass blades
 */
export function GrassInstances({ count = 10000, areaSize = 100, biomes = DEFAULT_BIOMES, heightFunc = () => 0, height = 1.0, color = 0x4a7c23, }) {
    const geometry = useMemo(() => {
        const geo = new THREE.BufferGeometry();
        const h = height;
        const positions = new Float32Array([
            -0.05,
            0,
            0,
            0.05,
            0,
            0,
            0,
            h,
            0,
            0.05,
            0,
            0,
            0.03,
            h,
            0,
            0,
            h,
            0,
        ]);
        const normals = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geo.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
        return geo;
    }, [height]);
    const material = useMemo(() => {
        return new THREE.MeshStandardMaterial({
            color: new THREE.Color(color),
            roughness: 0.8,
            metalness: 0.0,
            side: THREE.DoubleSide,
        });
    }, [color]);
    const instances = useMemo(() => {
        return coreGenerateInstanceData(count, areaSize, heightFunc, biomes, ['marsh', 'forest', 'savanna', 'scrubland'], undefined, // seed
        sdfGetBiomeAt, noise3D, fbm);
    }, [count, areaSize, biomes, heightFunc]);
    // Cleanup
    useEffect(() => {
        return () => {
            geometry.dispose();
            material.dispose();
        };
    }, [geometry, material]);
    return (_jsx(GPUInstancedMesh, { geometry: geometry, material: material, count: count, instances: instances, enableWind: true, windStrength: 0.3, lodDistance: 80, castShadow: false, receiveShadow: true }));
}
/**
 * Instanced trees
 */
export function TreeInstances({ count = 500, areaSize = 100, biomes = DEFAULT_BIOMES, heightFunc = () => 0, }) {
    const geometry = useMemo(() => {
        // Simple tree geometry - cone for foliage
        return new THREE.ConeGeometry(1, 3, 6);
    }, []);
    const material = useMemo(() => {
        return new THREE.MeshStandardMaterial({
            color: 0x2d5a27,
            roughness: 0.85,
            metalness: 0.0,
        });
    }, []);
    const instances = useMemo(() => {
        return coreGenerateInstanceData(count, areaSize, heightFunc, biomes, ['forest', 'tundra'], undefined, // seed
        sdfGetBiomeAt, noise3D, fbm);
    }, [count, areaSize, biomes, heightFunc]);
    // Cleanup
    useEffect(() => {
        return () => {
            geometry.dispose();
            material.dispose();
        };
    }, [geometry, material]);
    return (_jsx(GPUInstancedMesh, { geometry: geometry, material: material, count: count, instances: instances, enableWind: true, windStrength: 0.15, lodDistance: 150, castShadow: true, receiveShadow: true }));
}
/**
 * Instanced rocks
 */
export function RockInstances({ count = 200, areaSize = 100, biomes = DEFAULT_BIOMES, heightFunc = () => 0, }) {
    const geometry = useMemo(() => {
        // Irregular rock geometry
        return new THREE.DodecahedronGeometry(0.5, 0);
    }, []);
    const material = useMemo(() => {
        return new THREE.MeshStandardMaterial({
            color: 0x696969,
            roughness: 0.9,
            metalness: 0.1,
        });
    }, []);
    const instances = useMemo(() => {
        return coreGenerateInstanceData(count, areaSize, heightFunc, biomes, ['mountain', 'tundra', 'desert', 'scrubland'], undefined, // seed
        sdfGetBiomeAt, noise3D, fbm);
    }, [count, areaSize, biomes, heightFunc]);
    // Cleanup
    useEffect(() => {
        return () => {
            geometry.dispose();
            material.dispose();
        };
    }, [geometry, material]);
    return (_jsx(GPUInstancedMesh, { geometry: geometry, material: material, count: count, instances: instances, enableWind: false, lodDistance: 120, castShadow: true, receiveShadow: true }));
}
//# sourceMappingURL=Instancing.js.map