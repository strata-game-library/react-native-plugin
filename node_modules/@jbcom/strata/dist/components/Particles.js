import { jsx as _jsx } from "react/jsx-runtime";
/**
 * GPU-Based Particle System React Components
 *
 * Provides React components for particle effects using GPU-instanced rendering.
 * @module components/Particles
 */
import { useFrame } from '@react-three/fiber';
import { forwardRef, useEffect, useImperativeHandle, useRef } from 'react';
import * as THREE from 'three';
import { ParticleEmitter as CoreParticleEmitter, } from '../core/particles';
function toVector3(value, defaultValue) {
    if (!value)
        return defaultValue;
    if (value instanceof THREE.Vector3)
        return value.clone();
    return new THREE.Vector3(value[0], value[1], value[2]);
}
/**
 * GPU-accelerated particle emitter component for creating particle effects.
 * Uses instanced rendering for high performance with thousands of particles.
 *
 * @example
 * ```tsx
 * // Basic fire effect
 * <ParticleEmitter
 *   position={[0, 0, 0]}
 *   velocity={[0, 2, 0]}
 *   startColor={0xff4400}
 *   endColor={0xff0000}
 *   startSize={0.3}
 *   endSize={0.05}
 *   lifetime={1.5}
 *   emissionRate={100}
 * />
 *
 * // With forces and custom shape
 * <ParticleEmitter
 *   shape="cone"
 *   shapeParams={{ radius: 1, angle: 45 }}
 *   forces={{ gravity: [0, -9.8, 0], wind: [1, 0, 0] }}
 *   maxParticles={5000}
 * />
 * ```
 *
 * @param props - ParticleEmitterProps configuration
 * @returns React element containing the particle system
 */
export const ParticleEmitter = forwardRef(({ position = [0, 0, 0], positionVariance, velocity = [0, 1, 0], velocityVariance, maxParticles = 1000, emissionRate = 100, lifetime = 2.0, lifetimeVariance = 0.2, startColor = 0xffffff, endColor = 0xffffff, startSize = 0.1, endSize = 0.05, sizeVariance = 0.2, startOpacity = 1.0, endOpacity = 0.0, shape = 'point', shapeParams, forces, behavior, texture, blending = THREE.AdditiveBlending, depthWrite = false, sortParticles = false, autoStart = true, paused = false, }, ref) => {
    const emitterRef = useRef(null);
    const groupRef = useRef(null);
    useEffect(() => {
        const config = {
            maxParticles,
            emissionRate: autoStart ? emissionRate : 0,
            lifetime,
            lifetimeVariance,
            position: toVector3(position, new THREE.Vector3(0, 0, 0)),
            positionVariance: toVector3(positionVariance, new THREE.Vector3(0, 0, 0)),
            velocity: toVector3(velocity, new THREE.Vector3(0, 1, 0)),
            velocityVariance: toVector3(velocityVariance, new THREE.Vector3(0.5, 0.5, 0.5)),
            startColor,
            endColor,
            startSize,
            endSize,
            sizeVariance,
            startOpacity,
            endOpacity,
            shape,
            shapeParams: shapeParams
                ? {
                    ...shapeParams,
                    direction: shapeParams.direction instanceof THREE.Vector3
                        ? shapeParams.direction
                        : shapeParams.direction
                            ? new THREE.Vector3(...shapeParams.direction)
                            : undefined,
                }
                : undefined,
            forces: forces
                ? {
                    ...forces,
                    gravity: forces.gravity instanceof THREE.Vector3
                        ? forces.gravity
                        : forces.gravity
                            ? new THREE.Vector3(...forces.gravity)
                            : undefined,
                    wind: forces.wind instanceof THREE.Vector3
                        ? forces.wind
                        : forces.wind
                            ? new THREE.Vector3(...forces.wind)
                            : undefined,
                }
                : undefined,
            behavior,
            texture,
            blending,
            depthWrite,
            sortParticles,
        };
        const emitter = new CoreParticleEmitter(config);
        emitterRef.current = emitter;
        if (groupRef.current) {
            groupRef.current.add(emitter.mesh);
        }
        return () => {
            if (groupRef.current && emitter.mesh.parent === groupRef.current) {
                groupRef.current.remove(emitter.mesh);
            }
            emitter.dispose();
        };
    }, [
        autoStart,
        behavior,
        blending,
        depthWrite,
        emissionRate,
        endColor,
        endOpacity,
        endSize,
        forces,
        lifetime,
        lifetimeVariance,
        maxParticles,
        position,
        positionVariance,
        shape,
        shapeParams,
        sizeVariance,
        sortParticles,
        startColor,
        startOpacity,
        startSize,
        texture,
        velocity,
        velocityVariance,
    ]);
    useEffect(() => {
        if (emitterRef.current) {
            emitterRef.current.setEmissionRate(paused ? 0 : emissionRate);
        }
    }, [paused, emissionRate]);
    useEffect(() => {
        if (emitterRef.current) {
            emitterRef.current.setPosition(toVector3(position, new THREE.Vector3(0, 0, 0)));
        }
    }, [position]);
    useImperativeHandle(ref, () => ({
        get emitter() {
            return emitterRef.current;
        },
        emit(count) {
            emitterRef.current?.emit(count);
        },
        burst(count) {
            emitterRef.current?.burst(count);
        },
        reset() {
            emitterRef.current?.reset();
        },
        setPosition(pos) {
            emitterRef.current?.setPosition(pos);
        },
        setEmissionRate(rate) {
            emitterRef.current?.setEmissionRate(rate);
        },
    }));
    useFrame((_, delta) => {
        if (emitterRef.current && !paused) {
            emitterRef.current.update(delta);
        }
    });
    return _jsx("group", { ref: groupRef });
});
ParticleEmitter.displayName = 'ParticleEmitter';
/**
 * Particle burst component for one-shot particle effects.
 * Useful for explosions, impacts, and other instantaneous effects.
 *
 * @example
 * ```tsx
 * // Explosion effect triggered by state
 * const [explode, setExplode] = useState(false);
 *
 * <ParticleBurst
 *   trigger={explode}
 *   count={200}
 *   position={hitPosition}
 *   velocity={[0, 5, 0]}
 *   velocityVariance={[3, 3, 3]}
 *   startColor={0xffff00}
 *   endColor={0xff0000}
 *   lifetime={0.8}
 *   onComplete={() => setExplode(false)}
 * />
 *
 * // Multiple bursts with unique keys
 * <ParticleBurst
 *   trigger={burstCount}
 *   count={50}
 *   shape="sphere"
 * />
 * ```
 *
 * @param props - ParticleBurstProps configuration
 * @returns React element containing the burst particle system
 */
export const ParticleBurst = forwardRef(({ count = 100, trigger = false, onComplete, ...props }, ref) => {
    const emitterRef = useRef(null);
    const lastTrigger = useRef(false);
    useImperativeHandle(ref, () => emitterRef.current);
    useEffect(() => {
        if (trigger !== lastTrigger.current && trigger) {
            emitterRef.current?.burst(count);
            lastTrigger.current = trigger;
        }
    }, [trigger, count]);
    return _jsx(ParticleEmitter, { ref: emitterRef, ...props, emissionRate: 0, autoStart: false });
});
ParticleBurst.displayName = 'ParticleBurst';
//# sourceMappingURL=Particles.js.map