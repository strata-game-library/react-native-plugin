import * as THREE from 'three';
import { describe, expect, it } from 'vitest';
import { batchLODObjects, calculateImpostorAngle, calculateLODLevel, calculateScreenSpaceSize, calculateVegetationDensity, createDitherPattern, createImpostorGeometry, createLODLevels, createVegetationLODLevels, generateLODGeometries, interpolateLODMaterials, LODManager, shouldUseLOD, simplifyGeometry, updateImpostorUV, } from '../core/lod';
describe('LODManager', () => {
    describe('instantiation', () => {
        it('should create a LODManager', () => {
            const manager = new LODManager();
            expect(manager).toBeDefined();
        });
    });
    describe('object registration', () => {
        it('should register LOD object', () => {
            const manager = new LODManager();
            const object = new THREE.Mesh();
            const config = {
                levels: [{ distance: 10 }, { distance: 30 }],
            };
            const id = manager.register(object, config);
            expect(id).toBeDefined();
        });
        it('should unregister LOD object', () => {
            const manager = new LODManager();
            const object = new THREE.Mesh();
            const config = {
                levels: [{ distance: 10 }],
            };
            const id = manager.register(object, config);
            const result = manager.unregister(id);
            expect(result).toBe(true);
        });
        it('should track registered object count', () => {
            const manager = new LODManager();
            manager.register(new THREE.Mesh(), { levels: [{ distance: 10 }] });
            manager.register(new THREE.Mesh(), { levels: [{ distance: 10 }] });
            expect(manager.count).toBe(2);
        });
        it('should generate unique IDs', () => {
            const manager = new LODManager();
            const id1 = manager.generateId();
            const id2 = manager.generateId();
            expect(id1).not.toBe(id2);
        });
    });
    describe('LOD updates', () => {
        it('should update LOD levels based on camera distance', () => {
            const manager = new LODManager();
            const object = new THREE.Mesh();
            object.position.set(0, 0, 10);
            manager.register(object, {
                levels: [{ distance: 5 }, { distance: 15 }],
            });
            expect(() => manager.update(new THREE.Vector3(0, 0, 0), 0.016)).not.toThrow();
        });
    });
    describe('state management', () => {
        it('should get current level', () => {
            const manager = new LODManager();
            const object = new THREE.Mesh();
            const id = manager.register(object, {
                levels: [{ distance: 10 }],
            });
            expect(manager.getCurrentLevel(id)).toBe(0);
        });
        it('should get transition progress', () => {
            const manager = new LODManager();
            const object = new THREE.Mesh();
            const id = manager.register(object, {
                levels: [{ distance: 10 }],
            });
            expect(manager.getTransitionProgress(id)).toBe(1);
        });
        it('should check if transitioning', () => {
            const manager = new LODManager();
            const object = new THREE.Mesh();
            const id = manager.register(object, {
                levels: [{ distance: 10 }],
            });
            expect(manager.isTransitioning(id)).toBe(false);
        });
        it('should get state', () => {
            const manager = new LODManager();
            const object = new THREE.Mesh();
            const id = manager.register(object, {
                levels: [{ distance: 10 }],
            });
            const state = manager.getState(id);
            expect(state).toBeDefined();
        });
    });
    describe('clear', () => {
        it('should clear all objects', () => {
            const manager = new LODManager();
            manager.register(new THREE.Mesh(), { levels: [{ distance: 10 }] });
            manager.clear();
            expect(manager.count).toBe(0);
        });
    });
});
describe('calculateLODLevel', () => {
    it('should return level 0 for close distance', () => {
        const objectPos = new THREE.Vector3(0, 0, 5);
        const cameraPos = new THREE.Vector3(0, 0, 0);
        const levels = [{ distance: 10 }, { distance: 30 }, { distance: 60 }];
        const level = calculateLODLevel(objectPos, cameraPos, levels);
        expect(level).toBe(0);
    });
    it('should return level 1 for medium distance', () => {
        const objectPos = new THREE.Vector3(0, 0, 20);
        const cameraPos = new THREE.Vector3(0, 0, 0);
        const levels = [{ distance: 10 }, { distance: 30 }, { distance: 60 }];
        const level = calculateLODLevel(objectPos, cameraPos, levels);
        expect(level).toBe(1);
    });
    it('should return last level for far distance', () => {
        const objectPos = new THREE.Vector3(0, 0, 100);
        const cameraPos = new THREE.Vector3(0, 0, 0);
        const levels = [{ distance: 10 }, { distance: 30 }, { distance: 60 }];
        const level = calculateLODLevel(objectPos, cameraPos, levels);
        expect(level).toBe(2);
    });
});
describe('createLODLevels', () => {
    it('should create LOD levels from distances', () => {
        const levels = createLODLevels([10, 30, 60]);
        expect(levels.length).toBe(3);
        expect(levels[0].distance).toBe(10);
    });
    it('should include geometries if provided', () => {
        const geometries = [new THREE.BoxGeometry(1, 1, 1), new THREE.BoxGeometry(0.5, 0.5, 0.5)];
        const levels = createLODLevels([10, 30], geometries);
        expect(levels[0].geometry).toBeDefined();
    });
});
describe('simplifyGeometry', () => {
    it('should simplify geometry', () => {
        const geometry = new THREE.BoxGeometry(1, 1, 1, 10, 10, 10);
        const simplified = simplifyGeometry(geometry, { targetRatio: 0.5 });
        expect(simplified).toBeInstanceOf(THREE.BufferGeometry);
    });
    it('should return clone if target ratio is 1', () => {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const simplified = simplifyGeometry(geometry, { targetRatio: 1 });
        expect(simplified).toBeDefined();
    });
});
describe('generateLODGeometries', () => {
    it('should generate multiple LOD geometries', () => {
        const base = new THREE.BoxGeometry(1, 1, 1, 8, 8, 8);
        const geometries = generateLODGeometries(base, 3);
        expect(geometries.length).toBe(3);
    });
});
describe('createImpostorGeometry', () => {
    it('should create impostor geometry', () => {
        const geometry = createImpostorGeometry(2, 2, 8);
        expect(geometry).toBeInstanceOf(THREE.PlaneGeometry);
        expect(geometry.userData.views).toBe(8);
    });
});
describe('updateImpostorUV', () => {
    it('should update UVs based on camera angle', () => {
        const geometry = createImpostorGeometry(1, 1, 8);
        expect(() => updateImpostorUV(geometry, Math.PI / 4, 8)).not.toThrow();
    });
});
describe('calculateImpostorAngle', () => {
    it('should calculate angle between object and camera', () => {
        const objectPos = new THREE.Vector3(0, 0, 0);
        const cameraPos = new THREE.Vector3(10, 0, 0);
        const angle = calculateImpostorAngle(objectPos, cameraPos);
        expect(angle).toBeCloseTo(Math.PI / 2, 2);
    });
});
describe('interpolateLODMaterials', () => {
    it('should interpolate material opacity', () => {
        const mat1 = new THREE.MeshBasicMaterial({ transparent: true });
        const mat2 = new THREE.MeshBasicMaterial({ transparent: true });
        expect(() => interpolateLODMaterials(mat1, mat2, 0.5)).not.toThrow();
    });
});
describe('createDitherPattern', () => {
    it('should create dither pattern texture', () => {
        const texture = createDitherPattern();
        expect(texture).toBeInstanceOf(THREE.DataTexture);
    });
    it('should accept custom size', () => {
        const texture = createDitherPattern(8);
        expect(texture).toBeDefined();
    });
});
describe('calculateScreenSpaceSize', () => {
    it('should calculate screen space size', () => {
        const objectPos = new THREE.Vector3(0, 0, 10);
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        camera.position.set(0, 0, 0);
        const size = calculateScreenSpaceSize(objectPos, 1.0, camera, 1080);
        expect(size).toBeGreaterThan(0);
    });
});
describe('shouldUseLOD', () => {
    it('should return true for small screen size', () => {
        expect(shouldUseLOD(20)).toBe(true);
    });
    it('should return false for large screen size', () => {
        expect(shouldUseLOD(100)).toBe(false);
    });
    it('should use custom threshold', () => {
        expect(shouldUseLOD(60, 70)).toBe(true);
        expect(shouldUseLOD(80, 70)).toBe(false);
    });
});
describe('createVegetationLODLevels', () => {
    it('should create vegetation LOD levels', () => {
        const levels = createVegetationLODLevels({
            highDetailDistance: 10,
            mediumDetailDistance: 30,
            lowDetailDistance: 60,
            impostorDistance: 100,
            cullDistance: 200,
        });
        expect(levels.length).toBe(5);
    });
});
describe('calculateVegetationDensity', () => {
    it('should return full density for close distance', () => {
        const density = calculateVegetationDensity(5, {
            highDetailDistance: 10,
            mediumDetailDistance: 30,
            lowDetailDistance: 60,
            impostorDistance: 100,
            cullDistance: 200,
        });
        expect(density).toBe(1.0);
    });
    it('should return 0 for beyond cull distance', () => {
        const density = calculateVegetationDensity(250, {
            highDetailDistance: 10,
            mediumDetailDistance: 30,
            lowDetailDistance: 60,
            impostorDistance: 100,
            cullDistance: 200,
        });
        expect(density).toBe(0);
    });
});
describe('batchLODObjects', () => {
    it('should batch objects by LOD level', () => {
        const objects = [new THREE.Mesh(), new THREE.Mesh(), new THREE.Mesh()];
        objects[0].position.set(0, 0, 5);
        objects[1].position.set(0, 0, 25);
        objects[2].position.set(0, 0, 50);
        const cameraPos = new THREE.Vector3(0, 0, 0);
        const levels = [{ distance: 10 }, { distance: 30 }, { distance: 60 }];
        const batches = batchLODObjects(objects, cameraPos, levels);
        expect(batches.size).toBe(3);
    });
});
describe('LODLevel interface', () => {
    it('should create level with distance', () => {
        const level = {
            distance: 25,
        };
        expect(level.distance).toBe(25);
    });
    it('should accept optional geometry', () => {
        const level = {
            distance: 25,
            geometry: new THREE.BoxGeometry(),
        };
        expect(level.geometry).toBeDefined();
    });
});
//# sourceMappingURL=lod.test.js.map