/**
 * God Rays Shaders
 *
 * Shaders for volumetric light shafts and god rays effects
 *
 * IMPORTANT: The god rays shader expects `uLightPosition` to be in **screen-space**
 * coordinates (UV space, 0.0 to 1.0 range), not world-space. You must project the
 * light's world position to screen space before passing it to the shader:
 *
 * ```typescript
 * const lightScreenPos = lightWorldPos.clone().project(camera);
 * uniforms.uLightPosition.value.set(
 *   (lightScreenPos.x + 1) * 0.5,
 *   (lightScreenPos.y + 1) * 0.5,
 *   lightScreenPos.z // z can be used to check if light is behind camera
 * );
 * ```
 */
import * as THREE from 'three';
export declare const godRaysVertexShader = "\n  varying vec2 vUv;\n  varying vec3 vWorldPosition;\n  \n  void main() {\n      vUv = uv;\n      vec4 worldPos = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPos.xyz;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n";
export declare const godRaysFragmentShader = "\n  uniform float uTime;\n  uniform vec3 uLightPosition;\n  uniform vec3 uLightColor;\n  uniform float uIntensity;\n  uniform float uDecay;\n  uniform float uDensity;\n  uniform float uWeight;\n  uniform float uExposure;\n  uniform int uSamples;\n  uniform vec2 uResolution;\n  uniform float uScattering;\n  uniform float uNoiseFactor;\n  \n  varying vec2 vUv;\n  varying vec3 vWorldPosition;\n  \n  float hash(vec2 p) {\n      return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n  }\n  \n  float noise(vec2 p) {\n      vec2 i = floor(p);\n      vec2 f = fract(p);\n      f = f * f * (3.0 - 2.0 * f);\n      \n      return mix(\n          mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),\n          mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x),\n          f.y\n      );\n  }\n  \n  float fbm(vec2 p) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      for (int i = 0; i < 4; i++) {\n          value += amplitude * noise(p);\n          p *= 2.0;\n          amplitude *= 0.5;\n      }\n      return value;\n  }\n  \n  void main() {\n      // Protect against division by zero when uSamples is 0\n      int samples = max(uSamples, 1);\n      \n      vec2 lightScreenPos = uLightPosition.xy;\n      vec2 deltaTexCoord = (vUv - lightScreenPos) * uDensity / float(samples);\n      \n      vec2 texCoord = vUv;\n      float illuminationDecay = 1.0;\n      vec3 color = vec3(0.0);\n      \n      for (int i = 0; i < 100; i++) {\n          if (i >= samples) break;\n          \n          texCoord -= deltaTexCoord;\n          \n          float noiseVal = 1.0;\n          if (uNoiseFactor > 0.0) {\n              noiseVal = 0.5 + 0.5 * fbm(texCoord * 10.0 + uTime * 0.1);\n          }\n          \n          float dist = length(texCoord - lightScreenPos);\n          float falloff = exp(-dist * uScattering);\n          \n          vec3 sampleColor = uLightColor * falloff * noiseVal;\n          sampleColor *= illuminationDecay * uWeight;\n          \n          color += sampleColor;\n          illuminationDecay *= uDecay;\n      }\n      \n      color *= uExposure * uIntensity;\n      \n      float alpha = length(color) * 0.5;\n      alpha = clamp(alpha, 0.0, 1.0);\n      \n      gl_FragColor = vec4(color, alpha);\n  }\n";
export declare const volumetricSpotlightVertexShader = "\n  varying vec3 vWorldPosition;\n  varying vec3 vNormal;\n  varying vec3 vViewDirection;\n  \n  void main() {\n      vec4 worldPos = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPos.xyz;\n      vNormal = normalize(normalMatrix * normal);\n      vViewDirection = normalize(cameraPosition - worldPos.xyz);\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n";
export declare const volumetricSpotlightFragmentShader = "\n  uniform float uTime;\n  uniform vec3 uLightColor;\n  uniform float uIntensity;\n  uniform float uAngle;\n  uniform float uPenumbra;\n  uniform float uDistance;\n  uniform float uDustDensity;\n  uniform vec3 uLightPosition;\n  uniform vec3 uLightDirection;\n  \n  varying vec3 vWorldPosition;\n  varying vec3 vNormal;\n  varying vec3 vViewDirection;\n  \n  float hash(vec3 p) {\n      p = fract(p * vec3(443.897, 441.423, 437.195));\n      p += dot(p, p.yxz + 19.19);\n      return fract((p.x + p.y) * p.z);\n  }\n  \n  float noise(vec3 p) {\n      vec3 i = floor(p);\n      vec3 f = fract(p);\n      f = f * f * (3.0 - 2.0 * f);\n      \n      return mix(\n          mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),\n              mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),\n          mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),\n              mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y),\n          f.z\n      );\n  }\n  \n  void main() {\n      vec3 toLight = uLightPosition - vWorldPosition;\n      float dist = length(toLight);\n      vec3 lightDir = normalize(toLight);\n      \n      float cosAngle = dot(-lightDir, normalize(uLightDirection));\n      float spotEffect = smoothstep(cos(uAngle + uPenumbra), cos(uAngle), cosAngle);\n      \n      float distAttenuation = 1.0 - smoothstep(0.0, uDistance, dist);\n      \n      float dust = noise(vWorldPosition * 2.0 + vec3(uTime * 0.1, uTime * 0.05, uTime * 0.08));\n      dust = 0.3 + 0.7 * dust;\n      dust *= uDustDensity;\n      \n      float edgeFade = 1.0 - abs(dot(vNormal, vViewDirection));\n      edgeFade = pow(edgeFade, 2.0);\n      \n      float alpha = spotEffect * distAttenuation * dust * uIntensity * edgeFade;\n      alpha = clamp(alpha, 0.0, 0.8);\n      \n      gl_FragColor = vec4(uLightColor, alpha);\n  }\n";
export declare const volumetricPointLightVertexShader = "\n  varying vec3 vWorldPosition;\n  varying vec3 vNormal;\n  varying vec3 vViewDirection;\n  varying float vDistanceToCenter;\n  \n  uniform vec3 uLightPosition;\n  \n  void main() {\n      vec4 worldPos = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPos.xyz;\n      vNormal = normalize(normalMatrix * normal);\n      vViewDirection = normalize(cameraPosition - worldPos.xyz);\n      vDistanceToCenter = length(worldPos.xyz - uLightPosition);\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n";
export declare const volumetricPointLightFragmentShader = "\n  uniform float uTime;\n  uniform vec3 uLightColor;\n  uniform float uIntensity;\n  uniform float uRadius;\n  uniform float uDustDensity;\n  uniform float uFlicker;\n  uniform vec3 uLightPosition;\n  \n  varying vec3 vWorldPosition;\n  varying vec3 vNormal;\n  varying vec3 vViewDirection;\n  varying float vDistanceToCenter;\n  \n  float hash(vec3 p) {\n      p = fract(p * vec3(443.897, 441.423, 437.195));\n      p += dot(p, p.yxz + 19.19);\n      return fract((p.x + p.y) * p.z);\n  }\n  \n  float noise(vec3 p) {\n      vec3 i = floor(p);\n      vec3 f = fract(p);\n      f = f * f * (3.0 - 2.0 * f);\n      \n      return mix(\n          mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),\n              mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),\n          mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),\n              mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y),\n          f.z\n      );\n  }\n  \n  void main() {\n      float distFactor = 1.0 - smoothstep(0.0, uRadius, vDistanceToCenter);\n      distFactor = pow(distFactor, 1.5);\n      \n      float dust = noise(vWorldPosition * 3.0 + vec3(uTime * 0.1));\n      dust = 0.5 + 0.5 * dust;\n      dust *= uDustDensity;\n      \n      float flicker = 1.0;\n      if (uFlicker > 0.0) {\n          flicker = 0.8 + 0.2 * sin(uTime * 10.0 + noise(vec3(uTime)) * 5.0);\n          flicker = mix(1.0, flicker, uFlicker);\n      }\n      \n      float edgeFade = 1.0 - abs(dot(vNormal, vViewDirection));\n      edgeFade = pow(edgeFade, 1.5);\n      \n      float alpha = distFactor * dust * uIntensity * flicker * edgeFade;\n      alpha = clamp(alpha, 0.0, 0.7);\n      \n      vec3 color = uLightColor * (1.0 + 0.2 * distFactor);\n      \n      gl_FragColor = vec4(color, alpha);\n  }\n";
export interface GodRaysUniforms {
    [uniform: string]: THREE.IUniform;
    uTime: {
        value: number;
    };
    uLightPosition: {
        value: THREE.Vector3;
    };
    uLightColor: {
        value: THREE.Color;
    };
    uIntensity: {
        value: number;
    };
    uDecay: {
        value: number;
    };
    uDensity: {
        value: number;
    };
    uWeight: {
        value: number;
    };
    uExposure: {
        value: number;
    };
    uSamples: {
        value: number;
    };
    uResolution: {
        value: THREE.Vector2;
    };
    uScattering: {
        value: number;
    };
    uNoiseFactor: {
        value: number;
    };
}
export interface VolumetricSpotlightUniforms {
    [uniform: string]: THREE.IUniform;
    uTime: {
        value: number;
    };
    uLightColor: {
        value: THREE.Color;
    };
    uIntensity: {
        value: number;
    };
    uAngle: {
        value: number;
    };
    uPenumbra: {
        value: number;
    };
    uDistance: {
        value: number;
    };
    uDustDensity: {
        value: number;
    };
    uLightPosition: {
        value: THREE.Vector3;
    };
    uLightDirection: {
        value: THREE.Vector3;
    };
}
export interface VolumetricPointLightUniforms {
    [uniform: string]: THREE.IUniform;
    uTime: {
        value: number;
    };
    uLightColor: {
        value: THREE.Color;
    };
    uIntensity: {
        value: number;
    };
    uRadius: {
        value: number;
    };
    uDustDensity: {
        value: number;
    };
    uFlicker: {
        value: number;
    };
    uLightPosition: {
        value: THREE.Vector3;
    };
}
export declare function createGodRaysUniforms(lightPosition: THREE.Vector3, lightColor: THREE.Color, options?: {
    intensity?: number;
    decay?: number;
    density?: number;
    weight?: number;
    exposure?: number;
    samples?: number;
    resolution?: THREE.Vector2;
    scattering?: number;
    noiseFactor?: number;
}): GodRaysUniforms;
export declare function createVolumetricSpotlightUniforms(lightPosition: THREE.Vector3, lightDirection: THREE.Vector3, lightColor: THREE.Color, options?: {
    intensity?: number;
    angle?: number;
    penumbra?: number;
    distance?: number;
    dustDensity?: number;
}): VolumetricSpotlightUniforms;
export declare function createVolumetricPointLightUniforms(lightPosition: THREE.Vector3, lightColor: THREE.Color, options?: {
    intensity?: number;
    radius?: number;
    dustDensity?: number;
    flicker?: number;
}): VolumetricPointLightUniforms;
//# sourceMappingURL=godRays.d.ts.map