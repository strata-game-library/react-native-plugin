/**
 * Ray marching shader - GPU-based SDF rendering
 *
 * Based on marching.js patterns for efficient ray marching
 */
export declare const raymarchingVertexShader = "\n  varying vec2 vUv;\n  varying vec3 vRayOrigin;\n  varying vec3 vRayDirection;\n  \n  void main() {\n    vUv = uv;\n    \n    // Fullscreen quad\n    gl_Position = vec4(position, 1.0);\n    \n    // Ray origin is camera position (passed as uniform)\n    // Ray direction calculated in fragment shader\n  }\n";
export declare const raymarchingFragmentShader = "\n  precision highp float;\n  \n  uniform vec3 uCameraPosition;\n  uniform mat4 uCameraMatrix;\n  uniform vec2 uResolution;\n  uniform float uTime;\n  uniform float uMaxSteps;\n  uniform float uMaxDistance;\n  uniform float uMinDistance;\n  uniform vec3 uBackgroundColor;\n  uniform float uFogStrength;\n  uniform vec3 uFogColor;\n  \n  varying vec2 vUv;\n  \n  // SDF scene function - will be injected\n  float sceneSDF(vec3 p);\n  \n  // Tetrahedron-based normal calculation (from marching.js)\n  vec3 calcNormal(vec3 pos, float eps) {\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n    return normalize( v1 * sceneSDF( pos + v1*eps ) +\n                      v2 * sceneSDF( pos + v2*eps ) +\n                      v3 * sceneSDF( pos + v3*eps ) +\n                      v4 * sceneSDF( pos + v4*eps ) );\n  }\n\n  vec3 calcNormal(vec3 pos) {\n    return calcNormal(pos, 0.002);\n  }\n\n  // Ray marching intersection (from marching.js)\n  vec2 calcRayIntersection( vec3 rayOrigin, vec3 rayDir, float maxd, float precis ) {\n    float latest = precis * 2.0;\n    float dist   = 0.0;\n    vec2 result;\n    vec2 res = vec2(-50000.0, -1.0);\n\n    for (int i = 0; i < 256; i++) {\n      if (float(i) >= uMaxSteps) break;\n      if (latest < precis || dist > maxd) break;\n\n      float sdf = sceneSDF(rayOrigin + rayDir * dist);\n      latest = sdf;\n      dist  += latest;\n    }\n\n    if( dist < maxd ) {\n      result.x = dist;\n      result.y = 1.0; // Material ID placeholder\n      res = result;\n    }\n\n    return res;\n  }\n  \n  void main() {\n    vec2 uv = vUv;\n    vec2 pos = uv * 2.0 - 1.0;\n    \n    // Aspect ratio correction\n    pos.x *= (uResolution.x / uResolution.y);\n    \n    vec3 ro = uCameraPosition;\n    vec3 rd = normalize( mat3(uCameraMatrix) * vec3( pos, 2.0 ) ); \n    \n    vec2 t = calcRayIntersection( ro, rd, uMaxDistance, uMinDistance );\n\n    vec4 color = vec4(uBackgroundColor, 1.0);\n    \n    if( t.x > -0.5 ) {\n      vec3 samplePos = ro + rd * t.x;\n      vec3 nor = calcNormal( samplePos );\n      \n      // Simple lighting\n      vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n      float diff = max(dot(nor, lightDir), 0.0);\n      vec3 albedo = vec3(0.8, 0.8, 0.9);\n      \n      color = vec4(albedo * (0.3 + 0.7 * diff), 1.0);\n      \n      // Fog\n      if (uFogStrength > 0.0) {\n        float fogFactor = exp(-uFogStrength * t.x);\n        color.rgb = mix(uFogColor, color.rgb, fogFactor);\n      }\n    }\n    \n    gl_FragColor = clamp(color, 0.0, 1.0);\n  }\n";
//# sourceMappingURL=raymarching.d.ts.map