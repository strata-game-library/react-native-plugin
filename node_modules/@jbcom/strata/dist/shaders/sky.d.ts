/**
 * Procedural Sky Shaders
 *
 * Day/night cycle, stars, weather effects
 */
export declare const skyVertexShader = "\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  \n  void main() {\n      vUv = uv;\n      vPosition = position;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n";
export declare const skyFragmentShader = "\n  uniform float uTime;\n  uniform float uSunIntensity;\n  uniform float uSunAngle;\n  uniform float uAmbientLight;\n  uniform float uStarVisibility;\n  uniform float uFogDensity;\n  uniform float uWeatherIntensity;\n  uniform vec2 uGyroTilt;\n  \n  varying vec2 vUv;\n  varying vec3 vPosition;\n  \n  // Simple noise for stars\n  float hash(vec2 p) {\n      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n  }\n  \n  // Sky gradient based on time of day\n  vec3 getSkyColor(float height) {\n      // Day sky: blue gradient\n      vec3 daySkyTop = vec3(0.4, 0.6, 0.9);\n      vec3 daySkyHorizon = vec3(0.7, 0.8, 0.95);\n      \n      // Night sky: dark blue/black\n      vec3 nightSkyTop = vec3(0.01, 0.01, 0.05);\n      vec3 nightSkyHorizon = vec3(0.1, 0.1, 0.2);\n      \n      // Interpolate based on sun intensity\n      vec3 skyTop = mix(nightSkyTop, daySkyTop, uSunIntensity);\n      vec3 skyHorizon = mix(nightSkyHorizon, daySkyHorizon, uSunIntensity);\n      \n      return mix(skyHorizon, skyTop, height);\n  }\n  \n  void main() {\n      // Apply gyroscopic tilt to UV\n      vec2 adjustedUv = vUv + uGyroTilt;\n      \n      // Calculate height with horizon adjustment\n      float height = adjustedUv.y;\n      \n      // Base sky color\n      vec3 skyColor = getSkyColor(height);\n      \n      // Add stars at night\n      if (uStarVisibility > 0.0) {\n          float starNoise = hash(floor(adjustedUv * 200.0));\n          if (starNoise > 0.995) {\n              float starBrightness = (starNoise - 0.995) * 200.0;\n              skyColor += vec3(starBrightness) * uStarVisibility;\n          }\n      }\n      \n      // Add sun glow\n      if (uSunIntensity > 0.0) {\n          float sunY = (uSunAngle / 180.0); // 0 to 1\n          float distToSun = distance(adjustedUv, vec2(0.5, sunY));\n          float sunGlow = smoothstep(0.2, 0.0, distToSun) * uSunIntensity;\n          skyColor += vec3(1.0, 0.9, 0.7) * sunGlow;\n      }\n      \n      // Weather effects (fog/clouds)\n      if (uWeatherIntensity > 0.0) {\n          float cloudNoise = hash(floor(adjustedUv * 10.0 + vec2(uTime * 0.1)));\n          vec3 cloudColor = vec3(0.8, 0.8, 0.85);\n          skyColor = mix(skyColor, cloudColor, cloudNoise * uWeatherIntensity * 0.5);\n      }\n      \n      // Apply fog density\n      if (uFogDensity > 0.0) {\n          vec3 fogColor = vec3(0.9, 0.9, 0.95);\n          skyColor = mix(skyColor, fogColor, uFogDensity * (1.0 - height));\n      }\n      \n      // Apply ambient lighting\n      skyColor *= (0.5 + uAmbientLight * 0.5);\n      \n      gl_FragColor = vec4(skyColor, 1.0);\n  }\n";
import * as THREE from 'three';
export interface SkyUniforms {
    [uniform: string]: THREE.IUniform;
    uTime: {
        value: number;
    };
    uSunIntensity: {
        value: number;
    };
    uSunAngle: {
        value: number;
    };
    uAmbientLight: {
        value: number;
    };
    uStarVisibility: {
        value: number;
    };
    uFogDensity: {
        value: number;
    };
    uWeatherIntensity: {
        value: number;
    };
    uGyroTilt: {
        value: THREE.Vector2;
    };
}
export declare function createSkyUniforms(timeOfDay: {
    sunIntensity: number;
    sunAngle: number;
    ambientLight: number;
    starVisibility: number;
    fogDensity: number;
}, weather: {
    intensity: number;
}, gyroTilt?: THREE.Vector2): SkyUniforms;
//# sourceMappingURL=sky.d.ts.map