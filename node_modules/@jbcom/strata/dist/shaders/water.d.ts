/**
 * Water shader - animated rippling water surface with procedural normal mapping
 *
 * Lifted from Otterfall procedural rendering system.
 */
export declare const waterVertexShader = "\n  uniform float time;\n  varying vec2 vUv;\n  varying vec3 vWorldPos;\n  varying vec3 vNormal;\n  varying vec3 vViewDir;\n  \n  void main() {\n    vUv = uv;\n    \n    vec3 pos = position;\n    \n    // Multi-layered wave displacement for more realistic water\n    float wave1 = sin(pos.x * 0.5 + time) * 0.05;\n    float wave2 = cos(pos.z * 0.3 + time * 1.3) * 0.03;\n    float wave3 = sin(pos.x * 1.2 - pos.z * 0.8 + time * 0.7) * 0.02;\n    pos.y += wave1 + wave2 + wave3;\n    \n    // Calculate approximate normal from wave derivatives\n    float dx = cos(pos.x * 0.5 + time) * 0.025 + sin(pos.x * 1.2 - pos.z * 0.8 + time * 0.7) * 0.024;\n    float dz = -sin(pos.z * 0.3 + time * 1.3) * 0.009 - cos(pos.x * 1.2 - pos.z * 0.8 + time * 0.7) * 0.016;\n    \n    vec3 tangentX = normalize(vec3(1.0, dx, 0.0));\n    vec3 tangentZ = normalize(vec3(0.0, dz, 1.0));\n    vNormal = normalize(cross(tangentZ, tangentX));\n    \n    vWorldPos = (modelMatrix * vec4(pos, 1.0)).xyz;\n    \n    // Calculate view direction for fresnel\n    vec4 worldPos = modelMatrix * vec4(pos, 1.0);\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n    \n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n";
export declare const waterFragmentShader = "\n  uniform float time;\n  varying vec2 vUv;\n  varying vec3 vWorldPos;\n  varying vec3 vNormal;\n  varying vec3 vViewDir;\n  \n  // Procedural noise for water detail\n  float hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n  }\n  \n  float noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n  }\n  \n  // Fresnel effect for realistic water reflections\n  float fresnel(vec3 viewDir, vec3 normal, float power) {\n    return pow(1.0 - max(dot(viewDir, normal), 0.0), power);\n  }\n  \n  // Procedural normal map simulation\n  vec3 proceduralNormal(vec2 uv, float time) {\n    // Two layers of scrolling noise for normal perturbation\n    vec2 uv1 = uv * 4.0 + vec2(time * 0.05, time * 0.03);\n    vec2 uv2 = uv * 3.0 - vec2(time * 0.04, time * 0.06);\n    \n    float n1 = noise(uv1);\n    float n2 = noise(uv2);\n    \n    // Create normal perturbation\n    vec3 normalOffset = vec3(\n      (n1 - 0.5) * 0.3,\n      1.0,\n      (n2 - 0.5) * 0.3\n    );\n    \n    return normalize(normalOffset);\n  }\n  \n  void main() {\n    // Base water colors\n    vec3 deepColor = vec3(0.02, 0.1, 0.15);\n    vec3 shallowColor = vec3(0.1, 0.3, 0.4);\n    vec3 foamColor = vec3(0.8, 0.9, 0.95);\n    vec3 reflectionColor = vec3(0.6, 0.7, 0.8);\n    \n    // Animated UV scrolling for detail\n    vec2 scrollUV1 = vWorldPos.xz * 0.5 + vec2(time * 0.02, time * 0.015);\n    vec2 scrollUV2 = vWorldPos.xz * 0.3 - vec2(time * 0.015, time * 0.025);\n    \n    // Multi-layered ripple pattern with UV scrolling\n    float ripple1 = sin(scrollUV1.x * 4.0) * cos(scrollUV1.y * 3.0);\n    float ripple2 = sin(scrollUV2.x * 5.0) * cos(scrollUV2.y * 4.0);\n    float ripple = (ripple1 + ripple2) * 0.25 + 0.5;\n    \n    // Procedural normal map for surface detail\n    vec3 detailNormal = proceduralNormal(vWorldPos.xz * 0.2, time);\n    vec3 finalNormal = normalize(vNormal + detailNormal * 0.3);\n    \n    // Depth gradient based on distance from center\n    float depth = length(vWorldPos.xz) / 50.0;\n    depth = clamp(depth, 0.0, 1.0);\n    \n    // Fresnel effect for reflections\n    float fresnelFactor = fresnel(vViewDir, finalNormal, 3.0);\n    \n    // Mix colors based on depth\n    vec3 col = mix(shallowColor, deepColor, depth);\n    \n    // Add ripple highlights\n    col += ripple * 0.08;\n    \n    // Add fresnel reflections\n    col = mix(col, reflectionColor, fresnelFactor * 0.4);\n    \n    // Foam at edges (shallow water) with animated detail\n    float foamNoise = noise(vWorldPos.xz * 2.0 + time * 0.5);\n    float foam = smoothstep(0.8, 1.0, 1.0 - depth) * ripple * foamNoise;\n    col = mix(col, foamColor, foam * 0.4);\n    \n    // Specular highlights from normal\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));\n    float specular = pow(max(dot(reflect(-lightDir, finalNormal), vViewDir), 0.0), 32.0);\n    col += specular * 0.3;\n    \n    // Transparency based on depth and fresnel\n    float alpha = mix(0.6, 0.9, depth) * (1.0 - fresnelFactor * 0.2);\n    \n    gl_FragColor = vec4(col, alpha);\n  }\n";
/**
 * Advanced water shader with caustics
 *
 * Lifted from Otterfall prototype.
 */
export declare const advancedWaterVertexShader = "\n  uniform float uTime;\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  varying float vElevation;\n  \n  float hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n  }\n  \n  float noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n  }\n  \n  float fbm(vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    \n    for (int i = 0; i < 4; i++) {\n      value += amplitude * noise(p * frequency);\n      amplitude *= 0.5;\n      frequency *= 2.0;\n    }\n    \n    return value;\n  }\n  \n  void main() {\n    vUv = uv;\n    vPosition = position;\n    \n    vec3 pos = position;\n    \n    float wave1 = sin(pos.x * 0.4 + uTime * 0.8) * 0.15;\n    float wave2 = sin(pos.y * 0.3 + uTime * 1.2) * 0.12;\n    float wave3 = sin((pos.x + pos.y) * 0.2 + uTime * 0.6) * 0.1;\n    \n    float noiseValue = fbm(vec2(pos.x * 0.1, pos.y * 0.1) + uTime * 0.05);\n    \n    pos.z += wave1 + wave2 + wave3 + noiseValue * 0.1;\n    \n    vElevation = pos.z;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n";
export declare const advancedWaterFragmentShader = "\n  uniform float uTime;\n  uniform vec3 uWaterColor;\n  uniform vec3 uDeepWaterColor;\n  uniform vec3 uFoamColor;\n  uniform float uCausticIntensity;\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  varying float vElevation;\n  \n  float hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n  }\n  \n  float noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n  }\n  \n  float caustic(vec2 uv, float time) {\n    vec2 p = uv * 10.0;\n    \n    float c1 = noise(p + time * 0.3);\n    float c2 = noise(p * 1.5 - time * 0.2);\n    float c3 = noise(p * 2.0 + time * 0.4);\n    \n    return (c1 + c2 + c3) / 3.0;\n  }\n  \n  void main() {\n    vec2 causticUV = vUv + vec2(sin(uTime * 0.5) * 0.1, cos(uTime * 0.3) * 0.1);\n    float causticPattern = caustic(causticUV, uTime);\n    causticPattern = pow(causticPattern, 2.0) * uCausticIntensity;\n    \n    float depthFactor = smoothstep(-0.1, 0.1, vElevation);\n    vec3 waterColor = mix(uDeepWaterColor, uWaterColor, depthFactor);\n    \n    vec3 finalColor = waterColor + vec3(causticPattern);\n    \n    if (vElevation > 0.08) {\n      finalColor = mix(finalColor, uFoamColor, smoothstep(0.08, 0.12, vElevation));\n    }\n    \n    float fresnel = pow(1.0 - abs(dot(normalize(vPosition), vec3(0.0, 0.0, 1.0))), 2.0);\n    finalColor += vec3(fresnel * 0.1);\n    \n    gl_FragColor = vec4(finalColor, 0.75);\n  }\n";
/**
 * Water shader uniforms factory
 */
export declare function createWaterUniforms(): {
    time: {
        value: number;
    };
};
/**
 * Advanced water uniforms factory
 */
export declare function createAdvancedWaterUniforms(): {
    uTime: {
        value: number;
    };
    uWaterColor: {
        value: number[];
    };
    uDeepWaterColor: {
        value: number[];
    };
    uFoamColor: {
        value: number[];
    };
    uCausticIntensity: {
        value: number;
    };
};
//# sourceMappingURL=water.d.ts.map