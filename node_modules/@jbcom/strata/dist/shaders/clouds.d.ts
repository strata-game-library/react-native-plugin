/**
 * Procedural Cloud Shaders
 *
 * Noise-based cloud generation with FBM, wind movement, and day/night adaptation
 */
import * as THREE from 'three';
export declare const cloudLayerVertexShader = "\n  varying vec2 vUv;\n  varying vec3 vWorldPosition;\n  \n  void main() {\n    vUv = uv;\n    vec4 worldPos = modelMatrix * vec4(position, 1.0);\n    vWorldPosition = worldPos.xyz;\n    gl_Position = projectionMatrix * viewMatrix * worldPos;\n  }\n";
export declare const cloudLayerFragmentShader = "\n  #define PI 3.14159265359\n  \n  uniform float uTime;\n  uniform float uCoverage;\n  uniform float uDensity;\n  uniform float uAltitude;\n  uniform vec3 uCloudColor;\n  uniform vec3 uShadowColor;\n  uniform vec2 uWindDirection;\n  uniform float uWindSpeed;\n  uniform float uSunIntensity;\n  uniform float uSunAngle;\n  uniform vec3 uSunColor;\n  uniform float uScale;\n  \n  varying vec2 vUv;\n  varying vec3 vWorldPosition;\n  \n  float hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n  }\n  \n  float noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n  }\n  \n  float fbm(vec2 p, int octaves) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    float maxValue = 0.0;\n    \n    for (int i = 0; i < 8; i++) {\n      if (i >= octaves) break;\n      value += amplitude * noise(p * frequency);\n      maxValue += amplitude;\n      amplitude *= 0.5;\n      frequency *= 2.0;\n    }\n    \n    return maxValue > 0.0 ? value / maxValue : 0.0;\n  }\n  \n  void main() {\n    vec2 windOffset = uWindDirection * uWindSpeed * uTime;\n    vec2 samplePos = (vUv + windOffset) * uScale;\n    \n    float cloud = fbm(samplePos, 6);\n    float detail = fbm(samplePos * 3.0 + 100.0, 4) * 0.5;\n    cloud = cloud + detail * 0.3;\n    \n    float threshold = 1.0 - uCoverage;\n    cloud = smoothstep(threshold - 0.1, threshold + 0.2, cloud);\n    cloud *= uDensity;\n    \n    float heightGradient = fbm(samplePos * 0.5, 3);\n    float cloudOpacity = cloud * (0.5 + heightGradient * 0.5);\n    \n    float sunHeight = sin(uSunAngle * PI / 180.0);\n    vec3 lightDir = normalize(vec3(0.5, sunHeight, 0.5));\n    float shadowSample = fbm(samplePos + lightDir.xz * 0.1, 4);\n    float shadow = smoothstep(0.3, 0.7, shadowSample);\n    \n    vec3 baseColor = mix(uShadowColor, uCloudColor, shadow);\n    vec3 sunTint = uSunColor * uSunIntensity * max(0.0, sunHeight);\n    vec3 finalColor = baseColor + sunTint * 0.2 * cloud;\n    \n    float edgeFade = smoothstep(0.0, 0.1, vUv.x) * smoothstep(1.0, 0.9, vUv.x);\n    edgeFade *= smoothstep(0.0, 0.1, vUv.y) * smoothstep(1.0, 0.9, vUv.y);\n    cloudOpacity *= edgeFade;\n    \n    gl_FragColor = vec4(finalColor, cloudOpacity);\n  }\n";
export declare const volumetricCloudVertexShader = "\n  varying vec3 vWorldPosition;\n  varying vec3 vViewDirection;\n  \n  void main() {\n    vec4 worldPos = modelMatrix * vec4(position, 1.0);\n    vWorldPosition = worldPos.xyz;\n    vViewDirection = normalize(cameraPosition - worldPos.xyz);\n    gl_Position = projectionMatrix * viewMatrix * worldPos;\n  }\n";
export declare const volumetricCloudFragmentShader = "\n  #define PI 3.14159265359\n  \n  uniform float uTime;\n  uniform float uCoverage;\n  uniform float uDensity;\n  uniform float uCloudBase;\n  uniform float uCloudHeight;\n  uniform vec3 uCloudColor;\n  uniform vec3 uShadowColor;\n  uniform vec2 uWindDirection;\n  uniform float uWindSpeed;\n  uniform float uSunIntensity;\n  uniform float uSunAngle;\n  uniform vec3 uSunColor;\n  uniform int uSteps;\n  uniform int uLightSteps;\n  \n  varying vec3 vWorldPosition;\n  varying vec3 vViewDirection;\n  \n  float hash3D(vec3 p) {\n    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);\n  }\n  \n  float noise3D(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n000 = hash3D(i);\n    float n100 = hash3D(i + vec3(1.0, 0.0, 0.0));\n    float n010 = hash3D(i + vec3(0.0, 1.0, 0.0));\n    float n110 = hash3D(i + vec3(1.0, 1.0, 0.0));\n    float n001 = hash3D(i + vec3(0.0, 0.0, 1.0));\n    float n101 = hash3D(i + vec3(1.0, 0.0, 1.0));\n    float n011 = hash3D(i + vec3(0.0, 1.0, 1.0));\n    float n111 = hash3D(i + vec3(1.0, 1.0, 1.0));\n    \n    return mix(\n      mix(mix(n000, n100, f.x), mix(n010, n110, f.x), f.y),\n      mix(mix(n001, n101, f.x), mix(n011, n111, f.x), f.y),\n      f.z\n    );\n  }\n  \n  float fbm3D(vec3 p, int octaves) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    float maxValue = 0.0;\n    \n    for (int i = 0; i < 8; i++) {\n      if (i >= octaves) break;\n      value += amplitude * noise3D(p * frequency);\n      maxValue += amplitude;\n      amplitude *= 0.5;\n      frequency *= 2.0;\n    }\n    \n    return maxValue > 0.0 ? value / maxValue : 0.0;\n  }\n  \n  float sampleCloudDensity(vec3 pos) {\n    float heightFactor = (pos.y - uCloudBase) / uCloudHeight;\n    if (heightFactor < 0.0 || heightFactor > 1.0) return 0.0;\n    \n    float heightShape = 4.0 * heightFactor * (1.0 - heightFactor);\n    \n    vec3 windOffset = vec3(uWindDirection.x, 0.0, uWindDirection.y) * uWindSpeed * uTime;\n    vec3 samplePos = (pos + windOffset) * 0.01;\n    \n    float baseCloud = fbm3D(samplePos, 5);\n    float detail = fbm3D(samplePos * 4.0 + 50.0, 3) * 0.3;\n    float cloud = baseCloud + detail;\n    \n    float threshold = 1.0 - uCoverage;\n    cloud = smoothstep(threshold, threshold + 0.3, cloud);\n    \n    return cloud * heightShape * uDensity;\n  }\n  \n  float lightMarch(vec3 pos) {\n    float sunHeight = sin(uSunAngle * PI / 180.0);\n    vec3 lightDir = normalize(vec3(0.3, max(0.1, sunHeight), 0.3));\n    float stepSize = uCloudHeight / max(float(uLightSteps), 1.0);\n    float totalDensity = 0.0;\n    \n    for (int i = 0; i < 16; i++) {\n      if (i >= uLightSteps) break;\n      pos += lightDir * stepSize;\n      totalDensity += sampleCloudDensity(pos) * stepSize;\n    }\n    \n    return exp(-totalDensity * 0.5);\n  }\n  \n  void main() {\n    vec3 rayDir = normalize(-vViewDirection);\n    \n    // Handle near-horizontal rays to prevent division by zero\n    if (abs(rayDir.y) < 0.0001) {\n      gl_FragColor = vec4(0.0);\n      return;\n    }\n    \n    float tMin = (uCloudBase - vWorldPosition.y) / rayDir.y;\n    float tMax = (uCloudBase + uCloudHeight - vWorldPosition.y) / rayDir.y;\n    \n    if (tMin > tMax) {\n      float temp = tMin;\n      tMin = tMax;\n      tMax = temp;\n    }\n    \n    tMin = max(0.0, tMin);\n    tMax = max(0.0, tMax);\n    \n    if (tMin >= tMax) {\n      gl_FragColor = vec4(0.0);\n      return;\n    }\n    \n    float stepSize = (tMax - tMin) / max(float(uSteps), 1.0);\n    vec3 pos = vWorldPosition + rayDir * tMin;\n    \n    vec4 accumulatedColor = vec4(0.0);\n    float accumulatedAlpha = 0.0;\n    \n    for (int i = 0; i < 64; i++) {\n      if (i >= uSteps) break;\n      if (accumulatedAlpha > 0.95) break;\n      \n      float density = sampleCloudDensity(pos);\n      \n      if (density > 0.01) {\n        float lightTransmittance = lightMarch(pos);\n        vec3 cloudCol = mix(uShadowColor, uCloudColor, lightTransmittance);\n        cloudCol += uSunColor * uSunIntensity * lightTransmittance * 0.3;\n        \n        float alpha = density * stepSize * 2.0;\n        alpha = 1.0 - exp(-alpha);\n        \n        accumulatedColor.rgb += cloudCol * alpha * (1.0 - accumulatedAlpha);\n        accumulatedAlpha += alpha * (1.0 - accumulatedAlpha);\n      }\n      \n      pos += rayDir * stepSize;\n    }\n    \n    gl_FragColor = vec4(accumulatedColor.rgb, accumulatedAlpha);\n  }\n";
export interface CloudLayerUniforms {
    [uniform: string]: THREE.IUniform;
    uTime: {
        value: number;
    };
    uCoverage: {
        value: number;
    };
    uDensity: {
        value: number;
    };
    uAltitude: {
        value: number;
    };
    uCloudColor: {
        value: THREE.Color;
    };
    uShadowColor: {
        value: THREE.Color;
    };
    uWindDirection: {
        value: THREE.Vector2;
    };
    uWindSpeed: {
        value: number;
    };
    uSunIntensity: {
        value: number;
    };
    uSunAngle: {
        value: number;
    };
    uSunColor: {
        value: THREE.Color;
    };
    uScale: {
        value: number;
    };
}
export interface VolumetricCloudUniforms {
    [uniform: string]: THREE.IUniform;
    uTime: {
        value: number;
    };
    uCoverage: {
        value: number;
    };
    uDensity: {
        value: number;
    };
    uCloudBase: {
        value: number;
    };
    uCloudHeight: {
        value: number;
    };
    uCloudColor: {
        value: THREE.Color;
    };
    uShadowColor: {
        value: THREE.Color;
    };
    uWindDirection: {
        value: THREE.Vector2;
    };
    uWindSpeed: {
        value: number;
    };
    uSunIntensity: {
        value: number;
    };
    uSunAngle: {
        value: number;
    };
    uSunColor: {
        value: THREE.Color;
    };
    uSteps: {
        value: number;
    };
    uLightSteps: {
        value: number;
    };
}
export declare function createCloudLayerUniforms(options: {
    coverage?: number;
    density?: number;
    altitude?: number;
    cloudColor?: THREE.Color;
    shadowColor?: THREE.Color;
    windDirection?: THREE.Vector2;
    windSpeed?: number;
    sunIntensity?: number;
    sunAngle?: number;
    sunColor?: THREE.Color;
    scale?: number;
}): CloudLayerUniforms;
export declare function createVolumetricCloudUniforms(options: {
    coverage?: number;
    density?: number;
    cloudBase?: number;
    cloudHeight?: number;
    cloudColor?: THREE.Color;
    shadowColor?: THREE.Color;
    windDirection?: THREE.Vector2;
    windSpeed?: number;
    sunIntensity?: number;
    sunAngle?: number;
    sunColor?: THREE.Color;
    steps?: number;
    lightSteps?: number;
}): VolumetricCloudUniforms;
//# sourceMappingURL=clouds.d.ts.map